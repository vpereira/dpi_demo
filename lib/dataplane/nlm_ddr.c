/*******************************************************************************
* Legal Notice:
* This product is the confidential property of NetLogic Microsystems Inc.
* ("NetLogic"), is provided under a non-disclosure agreement, and is protected
* under applicable copyright, patent, and trade secret laws. Unauthorized use,
* reproduction, distribution or other dissemination without the prior written
* authorization from NetLogic is strictly prohibited.
*
* NETLOGIC DISCLAIMS ALL WARRANTIES OF ANY NATURE, EXPRESS OR IMPLIED,
* INCLUDING, WITHOUT LIMITATION, THE WARRANTIES OF FITNESS FOR A PARTICULAR
* PURPOSE, MERCHANTABILITY AND/OR NON-INFRINGEMENT OF THIRD PARTY RIGHTS.
* NETLOGIC ASSUMES NO LIABILITY FOR ANY ERROR OR OMISSIONS IN THIS PRODUCT,OR
* FOR THE USE OF THIS PRODUCT. IN NO EVENT SHALL NETLOGIC BE LIABLE TO ANY OTHER
* PARTY FOR ANY SPECIAL, PUNITIVE, INCIDENTAL OR CONSEQUENTIAL DAMAGES, WHETHER
* BASED ON BREACH OF CONTRACT, TORT, PRODUCT LIABILITY, INFRINGEMENT OF
* INTELLECTUAL PROPERTY RIGHTS OR OTHERWISE. NETLOGIC RESERVES THE RIGHT TO MAKE
* CHANGES TO, OR DISCONTINUE, ITS PRODUCTS AT ANY TIME.
*
* Distribution of the product herein does not convey a license or any other
* right in any patent, trademark, or other intellectual property of NetLogic.
*
* Use of the product shall serve as acceptance of these terms and conditions.
* If you do not accept these terms, you should return or destroy the product
* and any other accompanying information immediately.
*
* Copyright, 2009, NetLogic Microsystems, Inc. All rights reserved.
*******************************************************************************/
#include <string.h>
#ifndef DEBUG
//#define DEBUG
#endif
#include <stdarg.h>
#include "nlm_system.h"
#include "nlm_packet_api_impl.h"
#include "nlm_ddr.h"

#define NO_DMA_FOR_DDR
#define NLM_USE_DDR2 0
#define NLM_DDR3_FREQ 333

#define SET_HW_REGISTER_FIELD(REG_NAME, REG_TYPE, FIELD_NAME, VAL) \
  { \
    union REG_TYPE tmp_FIELD_NAME; \
    tmp_FIELD_NAME.word32 = HW_REGISTER (REG_NAME); \
    tmp_FIELD_NAME.s.FIELD_NAME = VAL; \
    SET_HW_REGISTER (REG_NAME, tmp_FIELD_NAME.word32); \
  }

#define HW_REGISTER_FIELD(REG_NAME, REG_TYPE, FIELD_NAME, DEST) \
  { \
    union REG_TYPE tmp_FIELD_NAME; \
    tmp_FIELD_NAME.word32 = HW_REGISTER (REG_NAME); \
    DEST = tmp_FIELD_NAME.s.FIELD_NAME; \
  }

uint32_t nlm_ddr_fpga_clock_select = 0;
uint32_t nlm_ddr_fpga_ddr_32bit_mode = 0; /* 0 - default (64b) mode , 1 - 32b mode */
uint32_t nlm_ddr_fpga_ddr_ecc = 0;        /* 0 - disabled, 1 - enabled */

static nlm_status
nlm_device_ddr_write_ind_32 (nlm_phy_device_t *phy_device, uint64_t addr, uint32_t data)
{
  uint32_t pci_param, cnt, rw, addr_type, ctrl, addr_lsb, addr_msb, i;

  DPRINT ("Writing DDR addr 0x%016"PRIx64", data 0x%08x\n", addr, data);
  addr_lsb = addr & 0xFFFFffff;
  addr_msb = ((uint32_t)0x20000000) | ((addr >> 32) & 0xF);
  // DPRINT ("Writing IND_ADDR_LSB (0x%04x) 0x%08x\n", IND_ADDR_LSB, addr_lsb);
  SET_HW_REGISTER (IND_ADDR_LSB, addr_lsb);
  // DPRINT ("Writing IND_ADDR_MSB (0x%04x) 0x%08x\n", IND_ADDR_MSB, addr_msb);
  SET_HW_REGISTER (IND_ADDR_MSB, addr_msb);

  // DPRINT ("Writing IND_DATA0 (0x%04x) 0x%08x\n", IND_DATA0, data);
  SET_HW_REGISTER (IND_DATA0, data);

  cnt       = 4;
  rw        = 0; /* write */
  addr_type = 1; /* internal */
  pci_param = 0;
  ctrl      = (pci_param << 16) | (addr_type << 12) | (rw << 8) | cnt;

  // DPRINT ("Writing IND_CTRL (0x%04x) 0x%08x\n", IND_CTRL, ctrl);
  SET_HW_REGISTER (IND_CTRL, ctrl);

  // DPRINT ("Polling on IND_STATUS (0x%04x)\n", IND_CTRL);
  for (i = 0; i < DDR3_OP_TIMEOUT; i++)
    if (0 == (HW_REGISTER (IND_STATUS) & 0x01))
      return NLM_OK;

  return NLM_DDR3_CONTROLLER_TIMEOUT;
}

static nlm_status
nlm_device_ddr_write_ind_64 (nlm_phy_device_t *phy_device, uint64_t addr, uint64_t data)
{
  uint32_t pci_param, cnt, rw, addr_type, ctrl, addr_lsb, addr_msb, d0, d1, i;

  DPRINT ("Writing DDR addr 0x%016"PRIx64", data 0x%016"PRIx64"\n", addr, data);
  addr_lsb = addr & 0xFFFFffff;
  addr_msb = ((uint32_t)0x20000000) | ((addr >> 32) & 0xF);
  // DPRINT ("Writing IND_ADDR_LSB (0x%04x) 0x%08x\n", IND_ADDR_LSB, addr_lsb);
  SET_HW_REGISTER (IND_ADDR_LSB, addr_lsb);
  // DPRINT ("Writing IND_ADDR_MSB (0x%04x) 0x%08x\n", IND_ADDR_MSB, addr_msb);
  SET_HW_REGISTER (IND_ADDR_MSB, addr_msb);

  d0 = data;
  d1 = data >> 32;

  // DPRINT ("Writing IND_DATA0 (0x%04x) 0x%08x\n", IND_DATA0, data);
  SET_HW_REGISTER (IND_DATA0, d0);
  SET_HW_REGISTER (IND_DATA1, d1);

  cnt       = 8;
  rw        = 0; /* write */
  addr_type = 1; /* internal */
  pci_param = 0;
  ctrl      = (pci_param << 16) | (addr_type << 12) | (rw << 8) | cnt;

  // DPRINT ("Writing IND_CTRL (0x%04x) 0x%08x\n", IND_CTRL, ctrl);
  SET_HW_REGISTER (IND_CTRL, ctrl);

  // DPRINT ("Polling on IND_STATUS (0x%04x)\n", IND_CTRL);
  for (i = 0; i < DDR3_OP_TIMEOUT; i++)
    if (0 == (HW_REGISTER (IND_STATUS) & 0x01))
      return NLM_OK;

  return NLM_DDR3_CONTROLLER_TIMEOUT;
}

static nlm_status
nlm_device_ddr2_train (nlm_phy_device_t *phy_device)
{

  if (nlm_ddr_fpga_clock_select != 0)
    {
      pretty_assert (HW_REGISTER (SYS_RESET) == 0xFFFFffff);
      SET_HW_REGISTER (SYS_RESET, 0xFFFFfffe);
      SET_HW_REGISTER (FPGA_CLOCK_SELECT, nlm_ddr_fpga_clock_select);
      SET_HW_REGISTER (SYS_RESET, 0xFFFFffff);
    }

  SET_HW_REGISTER (0x9000, 0x0);
  SET_HW_REGISTER (0x9004, 0x01000101);
  SET_HW_REGISTER (0x9008, 0x01010000);
  SET_HW_REGISTER (0x900c, 0x00010100);
  SET_HW_REGISTER (0x9010, 0x0);
  SET_HW_REGISTER (0x9014, 0x00010000);
  SET_HW_REGISTER (0x9018, 0x0);
  SET_HW_REGISTER (0x901c, 0x0);
  SET_HW_REGISTER (0x9020, 0x0);
  SET_HW_REGISTER (0x9024, 0x0);

  if (nlm_ddr_fpga_ddr_32bit_mode)
    SET_HW_REGISTER (0x9028, 0x010000);
  else
    SET_HW_REGISTER (0x9028, 0x0);

  SET_HW_REGISTER (0x902c, 0x0);
  SET_HW_REGISTER (0x9030, 0x01010000);
  SET_HW_REGISTER (0x9034, 0x00010000);
  SET_HW_REGISTER (0x9038, 0x03000000);

  if (nlm_ddr_fpga_ddr_ecc)
    SET_HW_REGISTER (0x903c, 0x02000003);
  else
    SET_HW_REGISTER (0x903c, 0x02000000);

  SET_HW_REGISTER (0x9040, 0x00010201);
  SET_HW_REGISTER (0x9044, 0x01000001);
  SET_HW_REGISTER (0x9048, 0x00030200);
  SET_HW_REGISTER (0x904c, 0x03000003);
  SET_HW_REGISTER (0x9050, 0x00010202);
  SET_HW_REGISTER (0x9054, 0x04060c0a);
  SET_HW_REGISTER (0x9058, 0x02040002);
  SET_HW_REGISTER (0x905c, 0x03020000);
  SET_HW_REGISTER (0x9060, 0x05020303);
  SET_HW_REGISTER (0x9064, 0x000b0c04);
  SET_HW_REGISTER (0x9068, 0x06050000);
  SET_HW_REGISTER (0x906c, 0x0702000C);
  SET_HW_REGISTER (0x9070, 0x00030b02);
  SET_HW_REGISTER (0x9074, 0x00281900);
  SET_HW_REGISTER (0x9078, 0x00000005);
  SET_HW_REGISTER (0x907c, 0x0);
  SET_HW_REGISTER (0x9080, 0x0);
  SET_HW_REGISTER (0x9084, 0x0);
  SET_HW_REGISTER (0x9088, 0x0);
  SET_HW_REGISTER (0x908c, 0x0);
  SET_HW_REGISTER (0x9090, 0x0);
  SET_HW_REGISTER (0x9094, 0x0);
  SET_HW_REGISTER (0x9098, 0x0);
  SET_HW_REGISTER (0x909c, 0x0);
  SET_HW_REGISTER (0x90a0, 0x0);
  SET_HW_REGISTER (0x90a4, 0x0);
  SET_HW_REGISTER (0x90a8, 0x0);
  SET_HW_REGISTER (0x90ac, 0x0);
  SET_HW_REGISTER (0x90b0, 0x40000000);
  SET_HW_REGISTER (0x90b4, 0x0);
  SET_HW_REGISTER (0x90b8, 0x0);
  SET_HW_REGISTER (0x90bc, 0x0c000300);
  SET_HW_REGISTER (0x90c0, 0x04000300);
  SET_HW_REGISTER (0x90c4, 0x03080300);
  SET_HW_REGISTER (0x90c8, 0x0000401a);
  SET_HW_REGISTER (0x90cc, 0x03050000);
  SET_HW_REGISTER (0x90d0, 0x03050305);
  SET_HW_REGISTER (0x90d4, 0x00000305);
  SET_HW_REGISTER (0x90d8, 0x000003e8);
  SET_HW_REGISTER (0x90dc, 0x00000000);
  SET_HW_REGISTER (0x90e0, 0x0);
  SET_HW_REGISTER (0x90e4, 0x0);
  SET_HW_REGISTER (0x90e8, 0x0);
  SET_HW_REGISTER (0x90ec, 0x0);
  SET_HW_REGISTER (0x90f0, 0x00500000);
  SET_HW_REGISTER (0x90f4, 0x0);
  SET_HW_REGISTER (0x90f8, 0x000300c8);
  SET_HW_REGISTER (0x90fc, 0x000a36a6);
  SET_HW_REGISTER (0x9100, 0x00c8001c);
  SET_HW_REGISTER (0x9104, 0x00040000);
  SET_HW_REGISTER (0x9108, 0x0);
  SET_HW_REGISTER (0x910c, 0x00009c40);
  SET_HW_REGISTER (0x9110, 0x00000064);
  SET_HW_REGISTER (0x9114, 0x0);
  SET_HW_REGISTER (0x9118, 0x0);
  SET_HW_REGISTER (0x911c, 0x001e0678);
  SET_HW_REGISTER (0x9120, 0x001e0678);
  SET_HW_REGISTER (0x9124, 0x001e0678);
  SET_HW_REGISTER (0x9128, 0x001e0678);
  SET_HW_REGISTER (0x912c, 0x001e0678);
  SET_HW_REGISTER (0x9130, 0x001e0678);
  SET_HW_REGISTER (0x9134, 0x001e0678);
  SET_HW_REGISTER (0x9138, 0x001e0678);
  SET_HW_REGISTER (0x913c, 0x001e0678);
  SET_HW_REGISTER (0x9140, 0x000f1133);
  SET_HW_REGISTER (0x9144, 0xf3004b15);
  SET_HW_REGISTER (0x9148, 0xf3004b15);
  SET_HW_REGISTER (0x914c, 0xf3004b15);
  SET_HW_REGISTER (0x9150, 0xf3004b15);
  SET_HW_REGISTER (0x9154, 0xf3004b15);
  SET_HW_REGISTER (0x9158, 0xf3004b15);
  SET_HW_REGISTER (0x915c, 0xf3004b15);
  SET_HW_REGISTER (0x9160, 0xf3004b15);
  SET_HW_REGISTER (0x9164, 0xf3004b15);
  SET_HW_REGISTER (0x9168, 0x26c00400);
  SET_HW_REGISTER (0x916c, 0x26c00400);
  SET_HW_REGISTER (0x9170, 0x26c00400);
  SET_HW_REGISTER (0x9174, 0x26c00400);
  SET_HW_REGISTER (0x9178, 0x26c00400);
  SET_HW_REGISTER (0x917c, 0x26c00400);
  SET_HW_REGISTER (0x9180, 0x26c00400);
  SET_HW_REGISTER (0x9184, 0x26c00400);
  SET_HW_REGISTER (0x9188, 0x26c00400);
  SET_HW_REGISTER (0x918c, 0x00000004);
  SET_HW_REGISTER (0x9190, 0x00000028);
  SET_HW_REGISTER (0x9194, 0x0);
  SET_HW_REGISTER (0x9198, 0x0);
  SET_HW_REGISTER (0x919c, 0x0);
  SET_HW_REGISTER (0x91a0, 0x0);
  SET_HW_REGISTER (0x91a4, 0x0);
  SET_HW_REGISTER (0x91a8, 0x0);

  if (nlm_ddr_fpga_ddr_ecc)
    SET_HW_REGISTER (0x91ac, 0x1);
  else
    SET_HW_REGISTER (0x91ac, 0x0);

  SET_HW_REGISTER (0x91b0, 0x0);
  SET_HW_REGISTER (0x91b4, 0x0);
  SET_HW_REGISTER (0x91b8, 0x0);
  SET_HW_REGISTER (0x91bc, 0x0);
  SET_HW_REGISTER (0x91c0, 0x0);
  SET_HW_REGISTER (0x91c4, 0x0);
  SET_HW_REGISTER (0x91c8, 0x0);
  SET_HW_REGISTER (0x91cc, 0x0);
  SET_HW_REGISTER (0x91d0, 0x0);
  SET_HW_REGISTER (0x91d4, 0x0);
  SET_HW_REGISTER (0x91d8, 0x0);
  SET_HW_REGISTER (0x91dc, 0x0);
  SET_HW_REGISTER (0x91e0, 0x0);
  SET_HW_REGISTER (0x91e4, 0x0);
  SET_HW_REGISTER (0x91e8, 0x0);
  SET_HW_REGISTER (0x91ec, 0x0);
  SET_HW_REGISTER (0x91f0, 0x0);
  SET_HW_REGISTER (0x91f4, 0x0);
  SET_HW_REGISTER (0x91f8, 0x0);
  SET_HW_REGISTER (0x91fc, 0x0);
  SET_HW_REGISTER (0x9200, 0x0);
  SET_HW_REGISTER (0x9204, 0x0);
  SET_HW_REGISTER (0x9208, 0x0);
  SET_HW_REGISTER (0x920c, 0x0);
  SET_HW_REGISTER (0x9210, 0x0);
  SET_HW_REGISTER (0x9214, 0x0);
  SET_HW_REGISTER (0x9218, 0x0);
  SET_HW_REGISTER (0x921c, 0x0);
  SET_HW_REGISTER (0x9220, 0x0);
  SET_HW_REGISTER (0x9224, 0x0);
  SET_HW_REGISTER (0x9228, 0x0);
  SET_HW_REGISTER (0x922c, 0x0);
  SET_HW_REGISTER (0x9230, 0x0);
  SET_HW_REGISTER (0x9234, 0x0);
  SET_HW_REGISTER (0x9238, 0x0);
  SET_HW_REGISTER (0x923c, 0x0);
  SET_HW_REGISTER (0x9240, 0x0);
  SET_HW_REGISTER (0x9244, 0x0);
  SET_HW_REGISTER (0x9248, 0x0);
  SET_HW_REGISTER (0x924c, 0x0);
  SET_HW_REGISTER (0x9250, 0x0);
  SET_HW_REGISTER (0x9254, 0x0);
  SET_HW_REGISTER (0x9258, 0x0);
  SET_HW_REGISTER (0x925c, 0x0);
  SET_HW_REGISTER (0x9260, 0x0);
  SET_HW_REGISTER (0x9264, 0x0);
  SET_HW_REGISTER (0x9268, 0x0);
  SET_HW_REGISTER (0x926c, 0x0);
  SET_HW_REGISTER (0x9270, 0x0);
  SET_HW_REGISTER (0x9274, 0x0);
  SET_HW_REGISTER (0x9278, 0x0);
  SET_HW_REGISTER (0x927c, 0x0);
  SET_HW_REGISTER (0x9280, 0x0);
  SET_HW_REGISTER (0x9284, 0x0);
  SET_HW_REGISTER (0x9288, 0x0);
  SET_HW_REGISTER (0x928c, 0x0);
  SET_HW_REGISTER (0x9290, 0x0);
  SET_HW_REGISTER (0x9294, 0x0);
  SET_HW_REGISTER (0x9298, 0x0);
  SET_HW_REGISTER (0x929c, 0x0);
  SET_HW_REGISTER (0x92a0, 0x0);
  SET_HW_REGISTER (0x92a4, 0x0);
  SET_HW_REGISTER (0x92a8, 0x0);
  SET_HW_REGISTER (0x92ac, 0x0);
  SET_HW_REGISTER (0x92b0, 0x0);
  SET_HW_REGISTER (0x92b4, 0x0);
  SET_HW_REGISTER (0x92b8, 0x0);
  SET_HW_REGISTER (0x92bc, 0x0);
  SET_HW_REGISTER (0x92c0, 0x0);
  SET_HW_REGISTER (0x92c4, 0x0);
  SET_HW_REGISTER (0x92c8, 0x0);
  SET_HW_REGISTER (0x92cc, 0x0);
  SET_HW_REGISTER (0x92d0, 0x0);
  SET_HW_REGISTER (0x92d4, 0x0);
  SET_HW_REGISTER (0x92d8, 0x0);
  SET_HW_REGISTER (0x92dc, 0x0);
  SET_HW_REGISTER (0x92e0, 0x0);
  SET_HW_REGISTER (0x92e4, 0x0);
  SET_HW_REGISTER (0x92e8, 0x0);
  SET_HW_REGISTER (0x92ec, 0x0);
  SET_HW_REGISTER (0x92f0, 0x0);
  SET_HW_REGISTER (0x92f4, 0x0);
  SET_HW_REGISTER (0x92f8, 0x0);
  SET_HW_REGISTER (0x92fc, 0x0);
  SET_HW_REGISTER (0x9300, 0x0);
  SET_HW_REGISTER (0x9304, 0x0);
  SET_HW_REGISTER (0x9308, 0x00000078);
  SET_HW_REGISTER (0x930c, 0x0);
  SET_HW_REGISTER (0x9310, 0x01000100);
  SET_HW_REGISTER (0x9314, 0x02000200);
  SET_HW_REGISTER (0x9318, 0x00010202);
  SET_HW_REGISTER (0x931c, 0x00040200);
  SET_HW_REGISTER (0x9320, 0x00000302);
  SET_HW_REGISTER (0x9324, 0x0100000a);
  SET_HW_REGISTER (0x9328, 0x03050200);
  SET_HW_REGISTER (0x932c, 0x03050305);
  SET_HW_REGISTER (0x9330, 0x04638000);
  SET_HW_REGISTER (0x9334, 0x00040463);
  SET_HW_REGISTER (0x9338, 0x00000004);
  SET_HW_REGISTER (0x933c, 0x00000000);
  SET_HW_REGISTER (0x9340, 0x0);
  SET_HW_REGISTER (0x9344, 0x0);
  SET_HW_REGISTER (0x9348, 0x0);
  SET_HW_REGISTER (0x934c, 0x0);
  SET_HW_REGISTER (0x9350, 0x0);
  SET_HW_REGISTER (0x9354, 0x06060606);
  SET_HW_REGISTER (0x9358, 0x06060606);
  SET_HW_REGISTER (0x935c, 0x06060606);
  SET_HW_REGISTER (0x9360, 0x06060606);
  SET_HW_REGISTER (0x9364, 0x00000606);
  SET_HW_REGISTER (0x9368, 0x0);
  SET_HW_REGISTER (0x936c, 0x0);
  SET_HW_REGISTER (0x9370, 0x0);
  SET_HW_REGISTER (0x9374, 0x0);
  SET_HW_REGISTER (0x9378, 0x0);
  SET_HW_REGISTER (0x937c, 0x0);
  SET_HW_REGISTER (0x9380, 0x0);
  SET_HW_REGISTER (0x9384, 0x0);
  SET_HW_REGISTER (0x9388, 0x00100000);
  SET_HW_REGISTER (0x938c, 0x0000ffff);
  SET_HW_REGISTER (0x9390, 0x0);
  SET_HW_REGISTER (0x9394, 0x0);
  SET_HW_REGISTER (0x9398, 0x0);
  SET_HW_REGISTER (0x939c, 0x0);
  SET_HW_REGISTER (0x93a0, 0x0);
  SET_HW_REGISTER (0x93a4, 0x0);
  SET_HW_REGISTER (0x93a8, 0x0);
  SET_HW_REGISTER (0x93ac, 0x0);
  SET_HW_REGISTER (0x93b0, 0x0);
  SET_HW_REGISTER (0x93b4, 0x0);
  SET_HW_REGISTER (0x93b8, 0x0);
  SET_HW_REGISTER (0x93bc, 0x0);
  SET_HW_REGISTER (0x93c0, 0x0);
  SET_HW_REGISTER (0x93c4, 0x0);
  SET_HW_REGISTER (0x93c8, 0x0);
  SET_HW_REGISTER (0x93cc, 0x0);
  SET_HW_REGISTER (0x93d0, 0x0);
  SET_HW_REGISTER (0x93d4, 0x0);
  SET_HW_REGISTER (0x902c, 0x100);
  return NLM_OK;
}

static nlm_status
nlm_device_ddr3_static_train (nlm_phy_device_t *phy_device)
{
  uint32_t i, j, y = 0;
  /* Change the y assignment to 4 to enable the pipe cleaning.
  The DDR ctxt area should be bad without this code; */

  printf("[%s] ingress NLM_DDR3_FREQ : %d\n", __FUNCTION__, NLM_DDR3_FREQ);

  switch (NLM_DDR3_FREQ)
    {
      case 333:
        SET_HW_REGISTER (0x9000, 0x00000000);
        SET_HW_REGISTER (0x9004, 0x00000101);
        SET_HW_REGISTER (0x9008, 0x01010000);
        SET_HW_REGISTER (0x900c, 0x00010100);

        SET_HW_REGISTER (0x9010, 0x00000000);
        SET_HW_REGISTER (0x9014, 0x00010000);
        SET_HW_REGISTER (0x9018, 0x00000000);
        SET_HW_REGISTER (0x901c, 0x00000000);

        SET_HW_REGISTER (0x9020, 0x00000000);
        SET_HW_REGISTER (0x9024, 0x00000000);

        if (nlm_ddr_fpga_ddr_32bit_mode)
          SET_HW_REGISTER (0x9028, 0x010000);
        else
          SET_HW_REGISTER (0x9028, 0x0);

        SET_HW_REGISTER (0x902c, 0x00000000);

        SET_HW_REGISTER (0x9030, 0x01010000);
        SET_HW_REGISTER (0x9034, 0x00000000);
        SET_HW_REGISTER (0x9038, 0x03000000);

        if (nlm_ddr_fpga_ddr_ecc)
          SET_HW_REGISTER (0x903c, 0x00000003);
        else
          SET_HW_REGISTER (0x903c, 0x00000000);

        SET_HW_REGISTER (0x9040, 0x00000000);
        SET_HW_REGISTER (0x9044, 0x02000000);
        SET_HW_REGISTER (0x9048, 0x00030200);
        SET_HW_REGISTER (0x904c, 0x03000003);

        SET_HW_REGISTER (0x9050, 0x00010404);
        SET_HW_REGISTER (0x9054, 0x06060c0a);
        SET_HW_REGISTER (0x9058, 0x02040000);
        SET_HW_REGISTER (0x905c, 0x03020000);

        SET_HW_REGISTER (0x9060, 0x05040503);
        SET_HW_REGISTER (0x9064, 0x000c0c05);
        SET_HW_REGISTER (0x9068, 0x0c060000);
        SET_HW_REGISTER (0x906c, 0x0c020007);

        SET_HW_REGISTER (0x9070, 0x00051105);
        SET_HW_REGISTER (0x9074, 0x00281900);
        SET_HW_REGISTER (0x9078, 0x00000005);
        SET_HW_REGISTER (0x907c, 0x00000000);

        SET_HW_REGISTER (0x9080, 0x00000000);
        SET_HW_REGISTER (0x9084, 0x00000000);
        SET_HW_REGISTER (0x9088, 0x00000000);
        SET_HW_REGISTER (0x908c, 0x00000000);

        SET_HW_REGISTER (0x9090, 0x00000000);
        SET_HW_REGISTER (0x9094, 0x00000000);
        SET_HW_REGISTER (0x9098, 0x00000000);
        SET_HW_REGISTER (0x909c, 0x00000000);

        SET_HW_REGISTER (0x90a0, 0x00000000);
        SET_HW_REGISTER (0x90a4, 0x00000000);
        SET_HW_REGISTER (0x90a8, 0x00000000);
        SET_HW_REGISTER (0x90ac, 0x00000000);

        SET_HW_REGISTER (0x90b0, 0x00000000);
        SET_HW_REGISTER (0x90b4, 0x00000000);
        SET_HW_REGISTER (0x90b8, 0x00000000);
        SET_HW_REGISTER (0x90bc, 0x0c000300);

        SET_HW_REGISTER (0x90c0, 0x04000300);
        SET_HW_REGISTER (0x90c4, 0x050c0c00);
        SET_HW_REGISTER (0x90c8, 0x00004025);
        SET_HW_REGISTER (0x90cc, 0x0a240000);

        SET_HW_REGISTER (0x90d0, 0x0a240a24);
        SET_HW_REGISTER (0x90d4, 0x00000a24);
        SET_HW_REGISTER (0x90d8, 0x000003e8);
        SET_HW_REGISTER (0x90dc, 0x00000000);

        SET_HW_REGISTER (0x90e0, 0x00000000);
        SET_HW_REGISTER (0x90e4, 0x00000000);
        SET_HW_REGISTER (0x90e8, 0x00000000);
        SET_HW_REGISTER (0x90ec, 0x00000000);

        SET_HW_REGISTER (0x90f0, 0x00000000);
        SET_HW_REGISTER (0x90f4, 0x00000000);
        SET_HW_REGISTER (0x90f8, 0x00030200);
        SET_HW_REGISTER (0x90fc, 0x000a5b5e);

        SET_HW_REGISTER (0x9100, 0x02000028);
        SET_HW_REGISTER (0x9104, 0x00000000);
        SET_HW_REGISTER (0x9108, 0x00000000);
        SET_HW_REGISTER (0x910c, 0x00000004);

        SET_HW_REGISTER (0x9110, 0x00028b0b);
        SET_HW_REGISTER (0x9114, 0x00000000);
        SET_HW_REGISTER (0x9118, 0x00000000);
        SET_HW_REGISTER (0x911c, 0x003c0678);

        SET_HW_REGISTER (0x9120, 0x003f0678);
        SET_HW_REGISTER (0x9124, 0x00420678);
        SET_HW_REGISTER (0x9128, 0x00450678);
        SET_HW_REGISTER (0x912c, 0x004b0678);

        SET_HW_REGISTER (0x9130, 0x004e0678);
        SET_HW_REGISTER (0x9134, 0x00510678);
        SET_HW_REGISTER (0x9138, 0x00540678);
        SET_HW_REGISTER (0x913c, 0x00480678);

        SET_HW_REGISTER (0x9140, 0xd75fc69f);

        SET_HW_REGISTER (0x9144, 0xf5100b26);
        SET_HW_REGISTER (0x9148, 0xf5100b26);
        SET_HW_REGISTER (0x914c, 0xf5100b26);
        SET_HW_REGISTER (0x9150, 0xf5100b26);
        SET_HW_REGISTER (0x9154, 0xf5100b26);
        SET_HW_REGISTER (0x9158, 0xf5100b26);
        SET_HW_REGISTER (0x915c, 0xf5100b26);
        SET_HW_REGISTER (0x9160, 0xf5100b26);
        SET_HW_REGISTER (0x9164, 0xf5100b26);

        SET_HW_REGISTER (0x9168, 0x26c00400);
        SET_HW_REGISTER (0x916c, 0x26c00400);

        SET_HW_REGISTER (0x9170, 0x26c00400);
        SET_HW_REGISTER (0x9174, 0x26c00400);
        SET_HW_REGISTER (0x9178, 0x26c00400);
        SET_HW_REGISTER (0x917c, 0x26c00400);

        SET_HW_REGISTER (0x9180, 0x26c00400);
        SET_HW_REGISTER (0x9184, 0x26c00400);
        SET_HW_REGISTER (0x9188, 0x26c00400);
        SET_HW_REGISTER (0x918c, 0x00000105);

        SET_HW_REGISTER (0x9190, 0x0001046a);
        SET_HW_REGISTER (0x9194, 0x00000000);
        SET_HW_REGISTER (0x9198, 0x000007ff);
        SET_HW_REGISTER (0x919c, 0x00000000);

        SET_HW_REGISTER (0x91a0, 0x00000000);
        SET_HW_REGISTER (0x91a4, 0x00000000);
        SET_HW_REGISTER (0x91a8, 0x00000000);
        SET_HW_REGISTER (0x91ac, 0x00000000);
        SET_HW_REGISTER (0x91b0, 0x00000000);
        SET_HW_REGISTER (0x91b4, 0x00000000);
        SET_HW_REGISTER (0x91b8, 0x00000000);
        SET_HW_REGISTER (0x91bc, 0x00000000);
        SET_HW_REGISTER (0x91c0, 0x00000000);
        SET_HW_REGISTER (0x91c4, 0x00000000);
        SET_HW_REGISTER (0x91c8, 0x00000000);
        SET_HW_REGISTER (0x91cc, 0x00000000);
        SET_HW_REGISTER (0x91d0, 0x00000000);
        SET_HW_REGISTER (0x91d4, 0x00000000);
        SET_HW_REGISTER (0x91d8, 0x00000000);
        SET_HW_REGISTER (0x91dc, 0x00000000);
        SET_HW_REGISTER (0x91e0, 0x00000000);
        SET_HW_REGISTER (0x91e4, 0x00000000);
        SET_HW_REGISTER (0x91e8, 0x00000000);
        SET_HW_REGISTER (0x91ec, 0x00000000);
        SET_HW_REGISTER (0x91f0, 0x00000000);
        SET_HW_REGISTER (0x91f4, 0x00000000);
        SET_HW_REGISTER (0x91f8, 0x00000000);
        SET_HW_REGISTER (0x91fc, 0x00000000);

        SET_HW_REGISTER (0x9200, 0x00000000);
        SET_HW_REGISTER (0x9204, 0x00000000);
        SET_HW_REGISTER (0x9208, 0x00000000);
        SET_HW_REGISTER (0x920c, 0x00000000);
        SET_HW_REGISTER (0x9210, 0x00000000);
        SET_HW_REGISTER (0x9214, 0x00000000);
        SET_HW_REGISTER (0x9218, 0x00000000);
        SET_HW_REGISTER (0x921c, 0x00000000);
        SET_HW_REGISTER (0x9220, 0x00000000);
        SET_HW_REGISTER (0x9224, 0x00000000);
        SET_HW_REGISTER (0x9228, 0x00000000);
        SET_HW_REGISTER (0x922c, 0x00000000);
        SET_HW_REGISTER (0x9230, 0x00000000);
        SET_HW_REGISTER (0x9234, 0x00000000);
        SET_HW_REGISTER (0x9238, 0x00000000);
        SET_HW_REGISTER (0x923c, 0x00000000);
        SET_HW_REGISTER (0x9240, 0x00000000);
        SET_HW_REGISTER (0x9244, 0x00000000);
        SET_HW_REGISTER (0x9248, 0x00000000);
        SET_HW_REGISTER (0x924c, 0x00000000);
        SET_HW_REGISTER (0x9250, 0x00000000);
        SET_HW_REGISTER (0x9254, 0x00000000);
        SET_HW_REGISTER (0x9258, 0x00000000);
        SET_HW_REGISTER (0x925c, 0x00000000);
        SET_HW_REGISTER (0x9260, 0x00000000);
        SET_HW_REGISTER (0x9264, 0x00000000);
        SET_HW_REGISTER (0x9268, 0x00000000);
        SET_HW_REGISTER (0x926c, 0x00000000);
        SET_HW_REGISTER (0x9270, 0x00000000);
        SET_HW_REGISTER (0x9274, 0x00000000);
        SET_HW_REGISTER (0x9278, 0x00000000);
        SET_HW_REGISTER (0x927c, 0x00000000);
        SET_HW_REGISTER (0x9280, 0x00000000);
        SET_HW_REGISTER (0x9284, 0x00000000);
        SET_HW_REGISTER (0x9288, 0x00000000);
        SET_HW_REGISTER (0x928c, 0x00000000);
        SET_HW_REGISTER (0x9290, 0x00000000);
        SET_HW_REGISTER (0x9294, 0x00000000);
        SET_HW_REGISTER (0x9298, 0x00000000);
        SET_HW_REGISTER (0x929c, 0x00000000);
        SET_HW_REGISTER (0x92a0, 0x00000000);
        SET_HW_REGISTER (0x92a4, 0x00000000);
        SET_HW_REGISTER (0x92a8, 0x00000000);
        SET_HW_REGISTER (0x92ac, 0x00000000);
        SET_HW_REGISTER (0x92b0, 0x00000000);
        SET_HW_REGISTER (0x92b4, 0x00000000);
        SET_HW_REGISTER (0x92b8, 0x00000000);
        SET_HW_REGISTER (0x92bc, 0x00000000);
        SET_HW_REGISTER (0x92c0, 0x00000000);
        SET_HW_REGISTER (0x92c4, 0x00000000);
        SET_HW_REGISTER (0x92c8, 0x00000000);
        SET_HW_REGISTER (0x92cc, 0x00000000);
        SET_HW_REGISTER (0x92d0, 0x00000000);
        SET_HW_REGISTER (0x92d4, 0x00000000);
        SET_HW_REGISTER (0x92d8, 0x00000000);
        SET_HW_REGISTER (0x92dc, 0x00000000);
        SET_HW_REGISTER (0x92e0, 0x00000000);
        SET_HW_REGISTER (0x92e4, 0x00000000);
        SET_HW_REGISTER (0x92e8, 0x00000000);
        SET_HW_REGISTER (0x92ec, 0x00000000);
        SET_HW_REGISTER (0x92f0, 0x00000000);
        SET_HW_REGISTER (0x92f4, 0x00000000);
        SET_HW_REGISTER (0x92f8, 0x00000000);
        SET_HW_REGISTER (0x92fc, 0x00000000);

        SET_HW_REGISTER (0x9300, 0x00000000);
        SET_HW_REGISTER (0x9304, 0x00000000);
        SET_HW_REGISTER (0x9308, 0x00000078);
        SET_HW_REGISTER (0x930c, 0x01010000);

        SET_HW_REGISTER (0x9310, 0x01000100);
        SET_HW_REGISTER (0x9314, 0x02000100);
        SET_HW_REGISTER (0x9318, 0x00010402);
        SET_HW_REGISTER (0x931c, 0x02060202);

        SET_HW_REGISTER (0x9320, 0x000f0204);
        SET_HW_REGISTER (0x9324, 0x0100000a);
        SET_HW_REGISTER (0x9328, 0x0a240200);
        SET_HW_REGISTER (0x932c, 0x0a240a24);

        SET_HW_REGISTER (0x9330, 0x02208000);
        SET_HW_REGISTER (0x9334, 0x00460220);
        SET_HW_REGISTER (0x9338, 0x00000046);
        SET_HW_REGISTER (0x933c, 0x00000000);

        SET_HW_REGISTER (0x9340, 0x00000000);
        SET_HW_REGISTER (0x9344, 0x00000000);
        SET_HW_REGISTER (0x9348, 0x00000000);
        SET_HW_REGISTER (0x934c, 0x00000000);
        SET_HW_REGISTER (0x9350, 0x00000000);

        SET_HW_REGISTER (0x9354, 0x19191919);
        SET_HW_REGISTER (0x9358, 0x19191919);
        SET_HW_REGISTER (0x935c, 0x19191919);
        SET_HW_REGISTER (0x9360, 0x19191919);
        SET_HW_REGISTER (0x9364, 0x19191919);

        SET_HW_REGISTER (0x9368, 0x00000000);
        SET_HW_REGISTER (0x936c, 0x00000000);
        SET_HW_REGISTER (0x9370, 0x00000000);
        SET_HW_REGISTER (0x9374, 0x00000000);

        SET_HW_REGISTER (0x9378, 0x000d000c);
        SET_HW_REGISTER (0x937c, 0x000d000d);
        SET_HW_REGISTER (0x9380, 0x000d000d);
        SET_HW_REGISTER (0x9384, 0x000d000d);
        SET_HW_REGISTER (0x9388, 0x0010000d);

        SET_HW_REGISTER (0x938c, 0x0000ffff);

        SET_HW_REGISTER (0x9390, 0x00000000);
        SET_HW_REGISTER (0x9394, 0x00000000);
        SET_HW_REGISTER (0x9398, 0x00000000);
        SET_HW_REGISTER (0x939c, 0x00000000);
        SET_HW_REGISTER (0x93a0, 0x00000000);
        SET_HW_REGISTER (0x93a4, 0x00000000);
        SET_HW_REGISTER (0x93a8, 0x00000000);
        SET_HW_REGISTER (0x93ac, 0x00000000);

        SET_HW_REGISTER (0x93b0, 0x001e0000);
        SET_HW_REGISTER (0x93b4, 0x00240021);
        SET_HW_REGISTER (0x93b8, 0x002d0027);
        SET_HW_REGISTER (0x93bc, 0x00330030);
        SET_HW_REGISTER (0x93c0, 0x002a0036);

        SET_HW_REGISTER (0x93c4, 0x00000000);
        SET_HW_REGISTER (0x93c8, 0x00000a24);
        SET_HW_REGISTER (0x93cc, 0x00000a24);

        SET_HW_REGISTER (0x93d0, 0x00000000);
        SET_HW_REGISTER (0x93d4, 0x00000a24);
        SET_HW_REGISTER (0x93d8, 0x07080300);
        SET_HW_REGISTER (0x93dc, 0x00000507);

        SET_HW_REGISTER (0x93e0, 0x00000fff);
        SET_HW_REGISTER (0x93e4, 0x000007d0);
        SET_HW_REGISTER (0x93e8, 0x24101065);
        SET_HW_REGISTER (0x93ec, 0x00000170);

        SET_HW_REGISTER (0x902c, 0x00000100);
      break;

      case 400:
        SET_HW_REGISTER (0x9000, 0x00000000);
        SET_HW_REGISTER (0x9004, 0x00000101);
        SET_HW_REGISTER (0x9008, 0x01010000);
        SET_HW_REGISTER (0x900c, 0x00010100);

        SET_HW_REGISTER (0x9010, 0x00000000);
        SET_HW_REGISTER (0x9014, 0x00010000);
        SET_HW_REGISTER (0x9018, 0x00000000);
        SET_HW_REGISTER (0x901c, 0x00000000);

        SET_HW_REGISTER (0x9020, 0x00000000);
        SET_HW_REGISTER (0x9024, 0x00000000);

        if (nlm_ddr_fpga_ddr_32bit_mode)
          SET_HW_REGISTER (0x9028, 0x010000);
        else
          SET_HW_REGISTER (0x9028, 0x0);

        SET_HW_REGISTER (0x902c, 0x00000000);

        SET_HW_REGISTER (0x9030, 0x01010000);
        SET_HW_REGISTER (0x9034, 0x00000000);
        SET_HW_REGISTER (0x9038, 0x03000000);

        if (nlm_ddr_fpga_ddr_ecc)
          SET_HW_REGISTER (0x903c, 0x00000003);
        else
          SET_HW_REGISTER (0x903c, 0x00000000);

        SET_HW_REGISTER (0x9040, 0x00000000);
        SET_HW_REGISTER (0x9044, 0x02000000);
        SET_HW_REGISTER (0x9048, 0x00030200);
        SET_HW_REGISTER (0x904c, 0x03000003);

        SET_HW_REGISTER (0x9050, 0x00010404);
        SET_HW_REGISTER (0x9054, 0x06060c0a);
        SET_HW_REGISTER (0x9058, 0x02040000);
        SET_HW_REGISTER (0x905c, 0x03020000);

        SET_HW_REGISTER (0x9060, 0x05040603);
        SET_HW_REGISTER (0x9064, 0x000c0c05);
        SET_HW_REGISTER (0x9068, 0x0c060000);
        SET_HW_REGISTER (0x906c, 0x0c020007);

        SET_HW_REGISTER (0x9070, 0x00061406);
        SET_HW_REGISTER (0x9074, 0x00281900);
        SET_HW_REGISTER (0x9078, 0x00000005);
        SET_HW_REGISTER (0x907c, 0x00000000);

        SET_HW_REGISTER (0x9080, 0x00000000);
        SET_HW_REGISTER (0x9084, 0x00000000);
        SET_HW_REGISTER (0x9088, 0x00000000);
        SET_HW_REGISTER (0x908c, 0x00000000);

        SET_HW_REGISTER (0x9090, 0x00000000);
        SET_HW_REGISTER (0x9094, 0x00000000);
        SET_HW_REGISTER (0x9098, 0x00000000);
        SET_HW_REGISTER (0x909c, 0x00000000);

        SET_HW_REGISTER (0x90a0, 0x00000000);
        SET_HW_REGISTER (0x90a4, 0x00000000);
        SET_HW_REGISTER (0x90a8, 0x00000000);
        SET_HW_REGISTER (0x90ac, 0x00000000);

        SET_HW_REGISTER (0x90b0, 0x00000000);
        SET_HW_REGISTER (0x90b4, 0x00000000);
        SET_HW_REGISTER (0x90b8, 0x00000000);
        SET_HW_REGISTER (0x90bc, 0x0c000300);

        SET_HW_REGISTER (0x90c0, 0x04000300);
        SET_HW_REGISTER (0x90c4, 0x060f0c00);
        SET_HW_REGISTER (0x90c8, 0x0000402c);
        SET_HW_REGISTER (0x90cc, 0x0c2d0000);

        SET_HW_REGISTER (0x90d0, 0x0c2d0c2d);
        SET_HW_REGISTER (0x90d4, 0x00000c2d);
        SET_HW_REGISTER (0x90d8, 0x000003e8);
        SET_HW_REGISTER (0x90dc, 0x00000000);

        SET_HW_REGISTER (0x90e0, 0x00000000);
        SET_HW_REGISTER (0x90e4, 0x00000000);
        SET_HW_REGISTER (0x90e8, 0x00000000);
        SET_HW_REGISTER (0x90ec, 0x00000000);

        SET_HW_REGISTER (0x90f0, 0x00000000);
        SET_HW_REGISTER (0x90f4, 0x00000000);
        SET_HW_REGISTER (0x90f8, 0x00030200);
        SET_HW_REGISTER (0x90fc, 0x000a6de6);

        SET_HW_REGISTER (0x9100, 0x02000030);
        SET_HW_REGISTER (0x9104, 0x00000000);
        SET_HW_REGISTER (0x9108, 0x00000000);
        SET_HW_REGISTER (0x910c, 0x00000004);

        SET_HW_REGISTER (0x9110, 0x00030d40);
        SET_HW_REGISTER (0x9114, 0x00000000);
        SET_HW_REGISTER (0x9118, 0x00000000);

        SET_HW_REGISTER (0x911c, 0x00380678);
        SET_HW_REGISTER (0x9120, 0x004a0678);
        SET_HW_REGISTER (0x9124, 0x004d0678);
        SET_HW_REGISTER (0x9128, 0x00520678);
        SET_HW_REGISTER (0x912c, 0x00600678);
        SET_HW_REGISTER (0x9130, 0x00680678);
        SET_HW_REGISTER (0x9134, 0x006e0678);
        SET_HW_REGISTER (0x9138, 0x006e0678);
        SET_HW_REGISTER (0x913c, 0x00570678);

        SET_HW_REGISTER (0x9140, 0xd75fc69f);

        SET_HW_REGISTER (0x9144, 0xf5100b26);
        SET_HW_REGISTER (0x9148, 0xf5100b26);
        SET_HW_REGISTER (0x914c, 0xf5100b26);
        SET_HW_REGISTER (0x9150, 0xf5100b26);
        SET_HW_REGISTER (0x9154, 0xf5100b26);
        SET_HW_REGISTER (0x9158, 0xf5100b26);
        SET_HW_REGISTER (0x915c, 0xf5100b26);
        SET_HW_REGISTER (0x9160, 0xf5100b26);
        SET_HW_REGISTER (0x9164, 0xf5100b26);

        SET_HW_REGISTER (0x9168, 0x26c00400);
        SET_HW_REGISTER (0x916c, 0x26c00400);

        SET_HW_REGISTER (0x9170, 0x26c00400);
        SET_HW_REGISTER (0x9174, 0x26c00400);
        SET_HW_REGISTER (0x9178, 0x26c00400);
        SET_HW_REGISTER (0x917c, 0x26c00400);

        SET_HW_REGISTER (0x9180, 0x26c00400);
        SET_HW_REGISTER (0x9184, 0x26c00400);
        SET_HW_REGISTER (0x9188, 0x26c00400);
        SET_HW_REGISTER (0x918c, 0x00000105);

        SET_HW_REGISTER (0x9190, 0x00013880);
        SET_HW_REGISTER (0x9194, 0x00000000);
        SET_HW_REGISTER (0x9198, 0x000007ff);
        SET_HW_REGISTER (0x919c, 0x00000000);

        SET_HW_REGISTER (0x91a0, 0x00000000);
        SET_HW_REGISTER (0x91a4, 0x00000000);
        SET_HW_REGISTER (0x91a8, 0x00000000);
        SET_HW_REGISTER (0x91ac, 0x00000000);
        SET_HW_REGISTER (0x91b0, 0x00000000);
        SET_HW_REGISTER (0x91b4, 0x00000000);
        SET_HW_REGISTER (0x91b8, 0x00000000);
        SET_HW_REGISTER (0x91bc, 0x00000000);
        SET_HW_REGISTER (0x91c0, 0x00000000);
        SET_HW_REGISTER (0x91c4, 0x00000000);
        SET_HW_REGISTER (0x91c8, 0x00000000);
        SET_HW_REGISTER (0x91cc, 0x00000000);
        SET_HW_REGISTER (0x91d0, 0x00000000);
        SET_HW_REGISTER (0x91d4, 0x00000000);
        SET_HW_REGISTER (0x91d8, 0x00000000);
        SET_HW_REGISTER (0x91dc, 0x00000000);
        SET_HW_REGISTER (0x91e0, 0x00000000);
        SET_HW_REGISTER (0x91e4, 0x00000000);
        SET_HW_REGISTER (0x91e8, 0x00000000);
        SET_HW_REGISTER (0x91ec, 0x00000000);
        SET_HW_REGISTER (0x91f0, 0x00000000);
        SET_HW_REGISTER (0x91f4, 0x00000000);
        SET_HW_REGISTER (0x91f8, 0x00000000);
        SET_HW_REGISTER (0x91fc, 0x00000000);

        SET_HW_REGISTER (0x9200, 0x00000000);
        SET_HW_REGISTER (0x9204, 0x00000000);
        SET_HW_REGISTER (0x9208, 0x00000000);
        SET_HW_REGISTER (0x920c, 0x00000000);
        SET_HW_REGISTER (0x9210, 0x00000000);
        SET_HW_REGISTER (0x9214, 0x00000000);
        SET_HW_REGISTER (0x9218, 0x00000000);
        SET_HW_REGISTER (0x921c, 0x00000000);
        SET_HW_REGISTER (0x9220, 0x00000000);
        SET_HW_REGISTER (0x9224, 0x00000000);
        SET_HW_REGISTER (0x9228, 0x00000000);
        SET_HW_REGISTER (0x922c, 0x00000000);
        SET_HW_REGISTER (0x9230, 0x00000000);
        SET_HW_REGISTER (0x9234, 0x00000000);
        SET_HW_REGISTER (0x9238, 0x00000000);
        SET_HW_REGISTER (0x923c, 0x00000000);
        SET_HW_REGISTER (0x9240, 0x00000000);
        SET_HW_REGISTER (0x9244, 0x00000000);
        SET_HW_REGISTER (0x9248, 0x00000000);
        SET_HW_REGISTER (0x924c, 0x00000000);
        SET_HW_REGISTER (0x9250, 0x00000000);
        SET_HW_REGISTER (0x9254, 0x00000000);
        SET_HW_REGISTER (0x9258, 0x00000000);
        SET_HW_REGISTER (0x925c, 0x00000000);
        SET_HW_REGISTER (0x9260, 0x00000000);
        SET_HW_REGISTER (0x9264, 0x00000000);
        SET_HW_REGISTER (0x9268, 0x00000000);
        SET_HW_REGISTER (0x926c, 0x00000000);
        SET_HW_REGISTER (0x9270, 0x00000000);
        SET_HW_REGISTER (0x9274, 0x00000000);
        SET_HW_REGISTER (0x9278, 0x00000000);
        SET_HW_REGISTER (0x927c, 0x00000000);
        SET_HW_REGISTER (0x9280, 0x00000000);
        SET_HW_REGISTER (0x9284, 0x00000000);
        SET_HW_REGISTER (0x9288, 0x00000000);
        SET_HW_REGISTER (0x928c, 0x00000000);
        SET_HW_REGISTER (0x9290, 0x00000000);
        SET_HW_REGISTER (0x9294, 0x00000000);
        SET_HW_REGISTER (0x9298, 0x00000000);
        SET_HW_REGISTER (0x929c, 0x00000000);
        SET_HW_REGISTER (0x92a0, 0x00000000);
        SET_HW_REGISTER (0x92a4, 0x00000000);
        SET_HW_REGISTER (0x92a8, 0x00000000);
        SET_HW_REGISTER (0x92ac, 0x00000000);
        SET_HW_REGISTER (0x92b0, 0x00000000);
        SET_HW_REGISTER (0x92b4, 0x00000000);
        SET_HW_REGISTER (0x92b8, 0x00000000);
        SET_HW_REGISTER (0x92bc, 0x00000000);
        SET_HW_REGISTER (0x92c0, 0x00000000);
        SET_HW_REGISTER (0x92c4, 0x00000000);
        SET_HW_REGISTER (0x92c8, 0x00000000);
        SET_HW_REGISTER (0x92cc, 0x00000000);
        SET_HW_REGISTER (0x92d0, 0x00000000);
        SET_HW_REGISTER (0x92d4, 0x00000000);
        SET_HW_REGISTER (0x92d8, 0x00000000);
        SET_HW_REGISTER (0x92dc, 0x00000000);
        SET_HW_REGISTER (0x92e0, 0x00000000);
        SET_HW_REGISTER (0x92e4, 0x00000000);
        SET_HW_REGISTER (0x92e8, 0x00000000);
        SET_HW_REGISTER (0x92ec, 0x00000000);
        SET_HW_REGISTER (0x92f0, 0x00000000);
        SET_HW_REGISTER (0x92f4, 0x00000000);
        SET_HW_REGISTER (0x92f8, 0x00000000);
        SET_HW_REGISTER (0x92fc, 0x00000000);

        SET_HW_REGISTER (0x9300, 0x00000000);
        SET_HW_REGISTER (0x9304, 0x00000000);
        SET_HW_REGISTER (0x9308, 0x00000078);
        SET_HW_REGISTER (0x930c, 0x01010000);

        SET_HW_REGISTER (0x9310, 0x01000100);
        SET_HW_REGISTER (0x9314, 0x02000100);
        SET_HW_REGISTER (0x9318, 0x00010402);
        SET_HW_REGISTER (0x931c, 0x02070202);

        SET_HW_REGISTER (0x9320, 0x000f0304);
        SET_HW_REGISTER (0x9324, 0x0100000a);
        SET_HW_REGISTER (0x9328, 0x0c2d0200);
        SET_HW_REGISTER (0x932c, 0x0c2d0c2d);

        SET_HW_REGISTER (0x9330, 0x04208000);
        SET_HW_REGISTER (0x9334, 0x00460420);
        SET_HW_REGISTER (0x9338, 0x00000046);
        SET_HW_REGISTER (0x933c, 0x00000000);

        SET_HW_REGISTER (0x9340, 0x00000000);
        SET_HW_REGISTER (0x9344, 0x00000000);
        SET_HW_REGISTER (0x9348, 0x00000000);
        SET_HW_REGISTER (0x934c, 0x00000000);
        SET_HW_REGISTER (0x9350, 0x00000000);

        SET_HW_REGISTER (0x9354, 0x24242424);
        SET_HW_REGISTER (0x9358, 0x24241f1f);
        SET_HW_REGISTER (0x935c, 0x20201a1a);
        SET_HW_REGISTER (0x9360, 0x1f1f2424);
        SET_HW_REGISTER (0x9364, 0x00002424);

        SET_HW_REGISTER (0x9368, 0x00000000);
        SET_HW_REGISTER (0x936c, 0x00000000);
        SET_HW_REGISTER (0x9370, 0x00000000);
        SET_HW_REGISTER (0x9374, 0x00000000);

        SET_HW_REGISTER (0x9378, 0x000d000c);
        SET_HW_REGISTER (0x937c, 0x000d000d);
        SET_HW_REGISTER (0x9380, 0x000d000d);
        SET_HW_REGISTER (0x9384, 0x000d000d);
        SET_HW_REGISTER (0x9388, 0x0010000d);

        SET_HW_REGISTER (0x938c, 0x0000ffff);

        SET_HW_REGISTER (0x9390, 0x00000000);
        SET_HW_REGISTER (0x9394, 0x00000000);
        SET_HW_REGISTER (0x9398, 0x00000000);
        SET_HW_REGISTER (0x939c, 0x00000000);
        SET_HW_REGISTER (0x93a0, 0x00000000);
        SET_HW_REGISTER (0x93a4, 0x00000000);
        SET_HW_REGISTER (0x93a8, 0x00000000);
        SET_HW_REGISTER (0x93ac, 0x00000000);

        SET_HW_REGISTER (0x93b0, 0x001a0000);
        SET_HW_REGISTER (0x93b4, 0x002f002c);
        SET_HW_REGISTER (0x93b8, 0x00420034);
        SET_HW_REGISTER (0x93bc, 0x0050004c);
        SET_HW_REGISTER (0x93c0, 0x00390050);

        SET_HW_REGISTER (0x93c4, 0x00000000);
        SET_HW_REGISTER (0x93c8, 0x00000c2d);
        SET_HW_REGISTER (0x93cc, 0x00000c2d);

        SET_HW_REGISTER (0x93d0, 0x00000000);
        SET_HW_REGISTER (0x93d4, 0x00000c2d);
        SET_HW_REGISTER (0x93d8, 0x07080300);
        SET_HW_REGISTER (0x93dc, 0x00000507);

        SET_HW_REGISTER (0x93e0, 0x00000fff);
        SET_HW_REGISTER (0x93e4, 0x00000960);
        SET_HW_REGISTER (0x93e8, 0x24101065);
        SET_HW_REGISTER (0x93ec, 0x00000170);

        SET_HW_REGISTER (0x902c, 0x00000100);
      break;

      case 416:
        SET_HW_REGISTER (0x9000, 0x00000000);
        SET_HW_REGISTER (0x9004, 0x00000101);
        SET_HW_REGISTER (0x9008, 0x01010000);
        SET_HW_REGISTER (0x900c, 0x00010100);

        SET_HW_REGISTER (0x9010, 0x00000000);
        SET_HW_REGISTER (0x9014, 0x00010000);
        SET_HW_REGISTER (0x9018, 0x00000000);
        SET_HW_REGISTER (0x901c, 0x00000000);

        SET_HW_REGISTER (0x9020, 0x00000000);
        SET_HW_REGISTER (0x9024, 0x00000000);

        if (nlm_ddr_fpga_ddr_32bit_mode)
          SET_HW_REGISTER (0x9028, 0x010000);
        else
          SET_HW_REGISTER (0x9028, 0x0);

        SET_HW_REGISTER (0x902c, 0x00000000);

        SET_HW_REGISTER (0x9030, 0x01010000);
        SET_HW_REGISTER (0x9034, 0x00000000);
        SET_HW_REGISTER (0x9038, 0x03000000);

        if (nlm_ddr_fpga_ddr_ecc)
          SET_HW_REGISTER (0x903c, 0x02000003);
        else
          SET_HW_REGISTER (0x903c, 0x02000000);

        SET_HW_REGISTER (0x9040, 0x00000000);
        SET_HW_REGISTER (0x9044, 0x02000000);
        SET_HW_REGISTER (0x9048, 0x00030200);
        SET_HW_REGISTER (0x904c, 0x03000003);

        SET_HW_REGISTER (0x9050, 0x00010404);
        SET_HW_REGISTER (0x9054, 0x06060c0a);
        SET_HW_REGISTER (0x9058, 0x02040000);
        SET_HW_REGISTER (0x905c, 0x03020000);

        SET_HW_REGISTER (0x9060, 0x05040703);
        SET_HW_REGISTER (0x9064, 0x000c0c05);
        SET_HW_REGISTER (0x9068, 0x0c060000);
        SET_HW_REGISTER (0x906c, 0x0c020007);

        SET_HW_REGISTER (0x9070, 0x00071606);
        SET_HW_REGISTER (0x9074, 0x00281900);
        SET_HW_REGISTER (0x9078, 0x00000005);
        SET_HW_REGISTER (0x907c, 0x00000000);

        SET_HW_REGISTER (0x9080, 0x00000000);
        SET_HW_REGISTER (0x9084, 0x00000000);
        SET_HW_REGISTER (0x9088, 0x00000000);
        SET_HW_REGISTER (0x908c, 0x00000000);

        SET_HW_REGISTER (0x9090, 0x00000000);
        SET_HW_REGISTER (0x9094, 0x00000000);
        SET_HW_REGISTER (0x9098, 0x00000000);
        SET_HW_REGISTER (0x909c, 0x00000000);

        SET_HW_REGISTER (0x90a0, 0x00000000);
        SET_HW_REGISTER (0x90a4, 0x00000000);
        SET_HW_REGISTER (0x90a8, 0x00000000);
        SET_HW_REGISTER (0x90ac, 0x00000000);

        SET_HW_REGISTER (0x90b0, 0x00000000);
        SET_HW_REGISTER (0x90b4, 0x00000000);
        SET_HW_REGISTER (0x90b8, 0x00000000);
        SET_HW_REGISTER (0x90bc, 0x0c000300);

        SET_HW_REGISTER (0x90c0, 0x04000300);
        SET_HW_REGISTER (0x90c4, 0x070f0c00);
        SET_HW_REGISTER (0x90c8, 0x0000402e);
        SET_HW_REGISTER (0x90cc, 0x0cb20000);

        SET_HW_REGISTER (0x90d0, 0x0cb20cb2);
        SET_HW_REGISTER (0x90d4, 0x00000cb2);
        SET_HW_REGISTER (0x90d8, 0x000003e8);
        SET_HW_REGISTER (0x90dc, 0x00000000);

        SET_HW_REGISTER (0x90e0, 0x00000000);
        SET_HW_REGISTER (0x90e4, 0x00000000);
        SET_HW_REGISTER (0x90e8, 0x00000000);
        SET_HW_REGISTER (0x90ec, 0x00000000);

        SET_HW_REGISTER (0x90f0, 0x00000000);
        SET_HW_REGISTER (0x90f4, 0x00000000);
        SET_HW_REGISTER (0x90f8, 0x00030200);
        SET_HW_REGISTER (0x90fc, 0x000a7242);

        SET_HW_REGISTER (0x9100, 0x02000032);
        SET_HW_REGISTER (0x9104, 0x00000000);
        SET_HW_REGISTER (0x9108, 0x00000000);
        SET_HW_REGISTER (0x910c, 0x00000004);

        SET_HW_REGISTER (0x9110, 0x00032dce);
        SET_HW_REGISTER (0x9114, 0x00000000);
        SET_HW_REGISTER (0x9118, 0x00000000);

        SET_HW_REGISTER (0x911c, 0x00380678);
        SET_HW_REGISTER (0x9120, 0x004c0678);
        SET_HW_REGISTER (0x9124, 0x004f0678);
        SET_HW_REGISTER (0x9128, 0x00560678);
        SET_HW_REGISTER (0x912c, 0x00660678);
        SET_HW_REGISTER (0x9130, 0x006e0678);
        SET_HW_REGISTER (0x9134, 0x006e0678);
        SET_HW_REGISTER (0x9138, 0x006e0678);
        SET_HW_REGISTER (0x913c, 0x00580678);

        SET_HW_REGISTER (0x9140, 0xd75fc69f);

        SET_HW_REGISTER (0x9144, 0xf5100b26);
        SET_HW_REGISTER (0x9148, 0xf5100b26);
        SET_HW_REGISTER (0x914c, 0xf5100b26);
        SET_HW_REGISTER (0x9150, 0xf5100b26);
        SET_HW_REGISTER (0x9154, 0xf5100b26);
        SET_HW_REGISTER (0x9158, 0xf5100b26);
        SET_HW_REGISTER (0x915c, 0xf5100b26);
        SET_HW_REGISTER (0x9160, 0xf5100b26);
        SET_HW_REGISTER (0x9164, 0xf5100b26);

        SET_HW_REGISTER (0x9168, 0x26c00400);
        SET_HW_REGISTER (0x916c, 0x26c00400);

        SET_HW_REGISTER (0x9170, 0x26c00400);
        SET_HW_REGISTER (0x9174, 0x26c00400);
        SET_HW_REGISTER (0x9178, 0x26c00400);
        SET_HW_REGISTER (0x917c, 0x26c00400);

        SET_HW_REGISTER (0x9180, 0x26c00400);
        SET_HW_REGISTER (0x9184, 0x26c00400);
        SET_HW_REGISTER (0x9188, 0x26c00400);
        SET_HW_REGISTER (0x918c, 0x00000105);

        SET_HW_REGISTER (0x9190, 0x00014586);
        SET_HW_REGISTER (0x9194, 0x00000000);
        SET_HW_REGISTER (0x9198, 0x000007ff);
        SET_HW_REGISTER (0x919c, 0x00000000);

        SET_HW_REGISTER (0x91a0, 0x00000000);
        SET_HW_REGISTER (0x91a4, 0x00000000);
        SET_HW_REGISTER (0x91a8, 0x00000000);
        SET_HW_REGISTER (0x91ac, 0x00000000);
        SET_HW_REGISTER (0x91b0, 0x00000000);
        SET_HW_REGISTER (0x91b4, 0x00000000);
        SET_HW_REGISTER (0x91b8, 0x00000000);
        SET_HW_REGISTER (0x91bc, 0x00000000);
        SET_HW_REGISTER (0x91c0, 0x00000000);
        SET_HW_REGISTER (0x91c4, 0x00000000);
        SET_HW_REGISTER (0x91c8, 0x00000000);
        SET_HW_REGISTER (0x91cc, 0x00000000);
        SET_HW_REGISTER (0x91d0, 0x00000000);
        SET_HW_REGISTER (0x91d4, 0x00000000);
        SET_HW_REGISTER (0x91d8, 0x00000000);
        SET_HW_REGISTER (0x91dc, 0x00000000);
        SET_HW_REGISTER (0x91e0, 0x00000000);
        SET_HW_REGISTER (0x91e4, 0x00000000);
        SET_HW_REGISTER (0x91e8, 0x00000000);
        SET_HW_REGISTER (0x91ec, 0x00000000);
        SET_HW_REGISTER (0x91f0, 0x00000000);
        SET_HW_REGISTER (0x91f4, 0x00000000);
        SET_HW_REGISTER (0x91f8, 0x00000000);
        SET_HW_REGISTER (0x91fc, 0x00000000);

        SET_HW_REGISTER (0x9200, 0x00000000);
        SET_HW_REGISTER (0x9204, 0x00000000);
        SET_HW_REGISTER (0x9208, 0x00000000);
        SET_HW_REGISTER (0x920c, 0x00000000);
        SET_HW_REGISTER (0x9210, 0x00000000);
        SET_HW_REGISTER (0x9214, 0x00000000);
        SET_HW_REGISTER (0x9218, 0x00000000);
        SET_HW_REGISTER (0x921c, 0x00000000);
        SET_HW_REGISTER (0x9220, 0x00000000);
        SET_HW_REGISTER (0x9224, 0x00000000);
        SET_HW_REGISTER (0x9228, 0x00000000);
        SET_HW_REGISTER (0x922c, 0x00000000);
        SET_HW_REGISTER (0x9230, 0x00000000);
        SET_HW_REGISTER (0x9234, 0x00000000);
        SET_HW_REGISTER (0x9238, 0x00000000);
        SET_HW_REGISTER (0x923c, 0x00000000);
        SET_HW_REGISTER (0x9240, 0x00000000);
        SET_HW_REGISTER (0x9244, 0x00000000);
        SET_HW_REGISTER (0x9248, 0x00000000);
        SET_HW_REGISTER (0x924c, 0x00000000);
        SET_HW_REGISTER (0x9250, 0x00000000);
        SET_HW_REGISTER (0x9254, 0x00000000);
        SET_HW_REGISTER (0x9258, 0x00000000);
        SET_HW_REGISTER (0x925c, 0x00000000);
        SET_HW_REGISTER (0x9260, 0x00000000);
        SET_HW_REGISTER (0x9264, 0x00000000);
        SET_HW_REGISTER (0x9268, 0x00000000);
        SET_HW_REGISTER (0x926c, 0x00000000);
        SET_HW_REGISTER (0x9270, 0x00000000);
        SET_HW_REGISTER (0x9274, 0x00000000);
        SET_HW_REGISTER (0x9278, 0x00000000);
        SET_HW_REGISTER (0x927c, 0x00000000);
        SET_HW_REGISTER (0x9280, 0x00000000);
        SET_HW_REGISTER (0x9284, 0x00000000);
        SET_HW_REGISTER (0x9288, 0x00000000);
        SET_HW_REGISTER (0x928c, 0x00000000);
        SET_HW_REGISTER (0x9290, 0x00000000);
        SET_HW_REGISTER (0x9294, 0x00000000);
        SET_HW_REGISTER (0x9298, 0x00000000);
        SET_HW_REGISTER (0x929c, 0x00000000);
        SET_HW_REGISTER (0x92a0, 0x00000000);
        SET_HW_REGISTER (0x92a4, 0x00000000);
        SET_HW_REGISTER (0x92a8, 0x00000000);
        SET_HW_REGISTER (0x92ac, 0x00000000);
        SET_HW_REGISTER (0x92b0, 0x00000000);
        SET_HW_REGISTER (0x92b4, 0x00000000);
        SET_HW_REGISTER (0x92b8, 0x00000000);
        SET_HW_REGISTER (0x92bc, 0x00000000);
        SET_HW_REGISTER (0x92c0, 0x00000000);
        SET_HW_REGISTER (0x92c4, 0x00000000);
        SET_HW_REGISTER (0x92c8, 0x00000000);
        SET_HW_REGISTER (0x92cc, 0x00000000);
        SET_HW_REGISTER (0x92d0, 0x00000000);
        SET_HW_REGISTER (0x92d4, 0x00000000);
        SET_HW_REGISTER (0x92d8, 0x00000000);
        SET_HW_REGISTER (0x92dc, 0x00000000);
        SET_HW_REGISTER (0x92e0, 0x00000000);
        SET_HW_REGISTER (0x92e4, 0x00000000);
        SET_HW_REGISTER (0x92e8, 0x00000000);
        SET_HW_REGISTER (0x92ec, 0x00000000);
        SET_HW_REGISTER (0x92f0, 0x00000000);
        SET_HW_REGISTER (0x92f4, 0x00000000);
        SET_HW_REGISTER (0x92f8, 0x00000000);
        SET_HW_REGISTER (0x92fc, 0x00000000);

        SET_HW_REGISTER (0x9300, 0x00000000);
        SET_HW_REGISTER (0x9304, 0x00000000);
        SET_HW_REGISTER (0x9308, 0x00000078);
        SET_HW_REGISTER (0x930c, 0x01010000);

        SET_HW_REGISTER (0x9310, 0x01000100);
        SET_HW_REGISTER (0x9314, 0x02000100);
        SET_HW_REGISTER (0x9318, 0x00010402);
        SET_HW_REGISTER (0x931c, 0x02070202);

        SET_HW_REGISTER (0x9320, 0x000f0404);
        SET_HW_REGISTER (0x9324, 0x0100000a);
        SET_HW_REGISTER (0x9328, 0x0cb20200);
        SET_HW_REGISTER (0x932c, 0x0cb20cb2);

        SET_HW_REGISTER (0x9330, 0x04208000);
        SET_HW_REGISTER (0x9334, 0x00460420);
        SET_HW_REGISTER (0x9338, 0x00000046);
        SET_HW_REGISTER (0x933c, 0x00000000);

        SET_HW_REGISTER (0x9340, 0x00000000);
        SET_HW_REGISTER (0x9344, 0x00000000);
        SET_HW_REGISTER (0x9348, 0x00000000);
        SET_HW_REGISTER (0x934c, 0x00000000);
        SET_HW_REGISTER (0x9350, 0x00000000);

        SET_HW_REGISTER (0x9354, 0x24242424);
        SET_HW_REGISTER (0x9358, 0x22221f1f);
        SET_HW_REGISTER (0x935c, 0x20201a1a);
        SET_HW_REGISTER (0x9360, 0x1f1f2222);
        SET_HW_REGISTER (0x9364, 0x00002424);

        SET_HW_REGISTER (0x9368, 0x00000000);
        SET_HW_REGISTER (0x936c, 0x00000000);
        SET_HW_REGISTER (0x9370, 0x00000000);
        SET_HW_REGISTER (0x9374, 0x00000000);

        SET_HW_REGISTER (0x9378, 0x000d000c);
        SET_HW_REGISTER (0x937c, 0x000d000d);
        SET_HW_REGISTER (0x9380, 0x000d000d);
        SET_HW_REGISTER (0x9384, 0x000d000d);
        SET_HW_REGISTER (0x9388, 0x0010000d);

        SET_HW_REGISTER (0x938c, 0x0000ffff);

        SET_HW_REGISTER (0x9390, 0x00000000);
        SET_HW_REGISTER (0x9394, 0x00000000);
        SET_HW_REGISTER (0x9398, 0x00000000);
        SET_HW_REGISTER (0x939c, 0x00000000);
        SET_HW_REGISTER (0x93a0, 0x00000000);
        SET_HW_REGISTER (0x93a4, 0x00000000);
        SET_HW_REGISTER (0x93a8, 0x00000000);
        SET_HW_REGISTER (0x93ac, 0x00000000);

        SET_HW_REGISTER (0x93b0, 0x001a0000);
        SET_HW_REGISTER (0x93b4, 0x0031002e);
        SET_HW_REGISTER (0x93b8, 0x00480038);
        SET_HW_REGISTER (0x93bc, 0x00500050);
        SET_HW_REGISTER (0x93c0, 0x003a0050);

        SET_HW_REGISTER (0x93c4, 0x00000000);
        SET_HW_REGISTER (0x93c8, 0x00000cb2);
        SET_HW_REGISTER (0x93cc, 0x00000cb2);

        SET_HW_REGISTER (0x93d0, 0x00000000);
        SET_HW_REGISTER (0x93d4, 0x00000cb2);
        SET_HW_REGISTER (0x93d8, 0x07080300);
        SET_HW_REGISTER (0x93dc, 0x00000507);

        SET_HW_REGISTER (0x93e0, 0x00000fff);
        SET_HW_REGISTER (0x93e4, 0x00000960);
        SET_HW_REGISTER (0x93e8, 0x24101065);
        SET_HW_REGISTER (0x93ec, 0x00000170);

        SET_HW_REGISTER (0x902c, 0x00000100);
      break;

      default:
        return NLM_DDR3_UNSUPPORTED_FREQUENCY;
    }

  /* Poll for DDR3 initialization complete */
  for (i = 0; i < DDR3_OP_TIMEOUT; i++)
    {  // Bit 6 is init complete
      if ((1 << 6) & HW_REGISTER (DDR3_CTL_173))
        {
          for (j = 0; j < y; j++)
            TRY (nlm_device_ddr_write_ind_32 (phy_device,
                                              phy_device->config.size_of_ddr_memory / 2 + j * 4,
                                              0));
          for (j = 0; j < y; j++)
            TRY (nlm_device_ddr_write_ind_64 (phy_device,
                                              phy_device->config.size_of_ddr_memory / 2 + j * 4,
                                              0));
          return NLM_OK;
        }
    }

  return NLM_DDR3_CONTROLLER_TIMEOUT;
}

static void
nlm_device_ddr3_init_response (nlm_phy_device_t *phy_device, uint32_t slice)
{
  uint32_t i;
  if (phy_device->ddr3.m_save_responses)
    {
      phy_device->ddr3.m_delay[slice] = -1;
      for (i = 0; i < NLM_DDR3_MAX_DLL_DELAY; i++)
        phy_device->ddr3.m_response[slice][i] = VAL_Z;
    }
}

//
// Adjust the gate training open signal by adding a full cycle of delay.
//
static nlm_status
nlm_device_ddr3_incr_full_cycle_delay (nlm_phy_device_t *phy_device, uint32_t slice)
{
  nlm_device_ddr3_init_response (phy_device, slice);

  if ((phy_device->ddr3.m_phy_ctrl_1[slice] & 7) == 7)
    return NLM_DDR3_DELAY_CHANGE_FAIL;

  phy_device->ddr3.m_phy_ctrl_1[slice]++;
  SET_HW_REGISTER (DDR3_CTL_90 + 4 * slice, phy_device->ddr3.m_phy_ctrl_1[slice]);

  return NLM_OK;
}

//
// Adjust the gate training open signal by removing a full cycle of delay.
//
static nlm_status
nlm_device_ddr3_decr_full_cycle_delay (nlm_phy_device_t *phy_device, uint32_t slice)
{
  nlm_device_ddr3_init_response (phy_device, slice);

  if ((phy_device->ddr3.m_phy_ctrl_1[slice] & 7) == 0)
    return NLM_DDR3_DELAY_CHANGE_FAIL;

  phy_device->ddr3.m_phy_ctrl_1[slice]--;
  SET_HW_REGISTER (DDR3_CTL_90 + 4 * slice, phy_device->ddr3.m_phy_ctrl_1[slice]);

  return NLM_OK;
}

//
// Set the gate training open signal delay to the specified value.
//
static void
nlm_device_ddr3_set_full_cycle_delay (nlm_phy_device_t *phy_device, uint32_t slice, uint32_t value)
{
  pretty_assert ((value < 8) && (value >= 0) && "Calculated read data value is out of range (0-7)");

  if ((phy_device->ddr3.m_phy_ctrl_1[slice] & 7) != value)
    {
      nlm_device_ddr3_init_response (phy_device, slice);
      phy_device->ddr3.m_phy_ctrl_1[slice] = (phy_device->ddr3.m_phy_ctrl_1[slice] & ~(0x7)) | value;
      SET_HW_REGISTER (DDR3_CTL_90 + 4 * slice, phy_device->ddr3.m_phy_ctrl_1[slice]);
    }
}

//
// Adjust the gate training open signal by adding a half cycle of delay.
// This may be as simple as turning on the half cycle delay bit.
// However, if this bit is already on, then it involves removing this half
// cycle delay and adding in a full cycle of delay using phy control reg 1.
//
static nlm_status
nlm_device_ddr3_incr_half_cycle_delay (nlm_phy_device_t *phy_device, uint32_t slice)
{
  nlm_status result = NLM_OK;

  nlm_device_ddr3_init_response (phy_device, slice);

  if ((phy_device->ddr3.m_phy_ctrl_0[slice] & (1 << 16)) == 0)
    phy_device->ddr3.m_phy_ctrl_0[slice] = phy_device->ddr3.m_phy_ctrl_0[slice] | (1 << 16);
  else
    {
      phy_device->ddr3.m_phy_ctrl_0[slice] = phy_device->ddr3.m_phy_ctrl_0[slice] & ~(1 << 16);
      result = nlm_device_ddr3_incr_full_cycle_delay (phy_device, slice);
    }

  if (NLM_OK == result)
    {
      nlm_device_ddr3_init_response (phy_device, slice);
      SET_HW_REGISTER (DDR3_CTL_81 + 4 * slice, phy_device->ddr3.m_phy_ctrl_0[slice]);
    }

  return result;
}

//
// Adjust the gate training open signal by removing a half cycle of delay.
// This may be as simple as turning off the half cycle delay bit.
// However, if this bit is already off, then it involves adding this half
// cycle delay and removing in a full cycle of delay using phy control reg 1.
//
static nlm_status
nlm_device_ddr3_decr_half_cycle_delay (nlm_phy_device_t *phy_device, uint32_t slice)
{
  nlm_status result = NLM_OK;

  nlm_device_ddr3_init_response (phy_device, slice);

  if ((phy_device->ddr3.m_phy_ctrl_0[slice] & (1 << 16)) == 1)
    phy_device->ddr3.m_phy_ctrl_0[slice] = phy_device->ddr3.m_phy_ctrl_0[slice] & ~(1 << 16);
  else
    {
      phy_device->ddr3.m_phy_ctrl_0[slice] = phy_device->ddr3.m_phy_ctrl_0[slice] | (1 << 16);
      result = nlm_device_ddr3_decr_full_cycle_delay (phy_device, slice);
    }

  if (NLM_OK == result)
    {
      nlm_device_ddr3_init_response (phy_device, slice);
      SET_HW_REGISTER (DDR3_CTL_81 + 4 * slice, phy_device->ddr3.m_phy_ctrl_0[slice]);
    }

  return result;
}


static uint32_t
nlm_device_ddr3_get_edges (nlm_phy_device_t *phy_device, uint32_t slice, uint32_t startVal, uint32_t *reset)
{
  uint32_t size = 0;

  switch (phy_device->ddr3.leveling_type_status)
    {
      case WRITE:
        if (startVal != SX1)
          {
            phy_device->ddr3.edges[0] = S0X;
            phy_device->ddr3.edges[1] = SX1;
            size = 2;
          }
        else if (phy_device->ddr3.m_wrlvl_is_leveled)
          {
            phy_device->ddr3.edges[0] = SX1;
            size = 1;
          }
        else
          {
            // There may be multiple x->1 transitions, so figure out which one is correct.
            int data_delay = phy_device->ddr3.m_data_delay[phy_device->ddr3.m_cs_rank][slice];
            int ctrl_delay = phy_device->ddr3.m_ctrl_delay[phy_device->ddr3.m_cs_rank][slice];
            if ((ctrl_delay - data_delay) < (phy_device->ddr3.sim_ps_period >> 1))
              {
                phy_device->ddr3.edges[0] = SX1;
                size = 1;
              }
            else
              {
                phy_device->ddr3.edges[0] = S0X;
                phy_device->ddr3.edges[1] = SX1;
                size = 2;
              }
          }
        break;
      case READ:
        if (startVal == S0X)
          {
            phy_device->ddr3.edges[0] = S0X;
            phy_device->ddr3.edges[1] = SX1;
          }
        else
          {
            phy_device->ddr3.edges[0] = SX0;
            phy_device->ddr3.edges[1] = S0X;
          }
        size = 2;
        break;
      case GATE:
        if (phy_device->ddr3.m_gtlvl_is_leveled)
          {
            phy_device->ddr3.edges[0] = S0X;
            phy_device->ddr3.edges[1] = SX1;
            size = 2;
          }
        else
          {
            if (startVal == SX1 || startVal == S1X)
              {
                nlm_device_ddr3_decr_half_cycle_delay (phy_device, slice);
                *reset = 1;
              }
            if (phy_device->ddr3.m_in_preamble)
              {
                phy_device->ddr3.edges[0] = S0X;
                phy_device->ddr3.edges[1] = SX1;
                size = 2;
              }
            else
              {
                // Need to be able to center on a pulse to search for the preamble
                phy_device->ddr3.edges[0] = S0X;
                phy_device->ddr3.edges[1] = SX1;
                phy_device->ddr3.edges[2] = S1X;
                size = 3;
              }
          }
        break;
      default:
        pretty_assert (0 && "unexpected leveling status");
    }
  return size;
}

static void
nlm_device_ddr3_load_delay_write (nlm_phy_device_t *phy_device, uint32_t slice, uint32_t delay)
{
  int32_t delta;
  int32_t full_cycle;
  uint32_t reg;
  uint32_t wrlvl_reg_addr = DDR3_CTL_236 + ((slice + 1) / 2) * 4; /* The first wrlvl register
                                                                     is in high portion of
                                                                     DDR3_CTL_236, hence the
                                                                     slice + 1 math */
  uint32_t shift_val = ((slice & 1) ^ 1) << 4; /* Short for: if the slice is even then shift by 16
                                                before writing to the destination register */

  reg = HW_REGISTER (wrlvl_reg_addr);
  reg = reg & (0xfffful << (shift_val ^ 16)); /* Short for: if shift is needed then clear MSB-16
                                                 else clear LSB-16 */
  SET_HW_REGISTER (wrlvl_reg_addr, reg | (delay << shift_val));

  full_cycle = phy_device->ddr3.m_dll_ctrl_0[slice] & 0xff;
  delta = delay + (full_cycle >> 2);
  if (delta >= full_cycle)
    delta -= full_cycle;
  phy_device->ddr3.m_dll_ctrl_0[slice] += delta << 16;

  SET_HW_REGISTER (DLL_CTRL_REG_0_0 + slice, phy_device->ddr3.m_dll_ctrl_0[slice]);
}

// Service one of the following request for each active slice
//   SETREQ    - Load the delay value without reading the response
//   GETREQ    - Read the response value without setting the delay
//   SETGETREQ - Load the delay value and read the corresponding response
//   TERMREQ   - Slice is complete and won't be sending any additional requests
static void
nlm_device_ddr3_serial_send_receive (nlm_phy_device_t *phy_device)
{
  int count = 0;
  int slice;
  int regval;                   // register value for reading response

  // Load all the delay values and adjust the count for who is still active
  for (slice = 0; slice < phy_device->ddr3.m_max_slice; slice++)
    {
      if (phy_device->ddr3.m_request[slice] != TERMREQ)
        {
          if (phy_device->ddr3.m_request[slice] & SETREQ)
            switch (phy_device->ddr3.leveling_type_status)
              {
                case WRITE:
                  nlm_device_ddr3_load_delay_write (phy_device, slice, phy_device->ddr3.m_delay[slice]);
                break;
                case READ:
                  {
                    uint32_t rdlvl_delay_reg_addr = DDR3_CTL_213 + (slice / 2) * 4;
                    uint32_t shift_val = (slice % 2) << 4;

                    regval = HW_REGISTER (rdlvl_delay_reg_addr);
                    regval = regval & (0xfffful << (shift_val ^ 16));
                    /* Short for: if shift is needed then clear MSB-16 else clear LSB-16 */
                    SET_HW_REGISTER (rdlvl_delay_reg_addr,
                                      regval | (phy_device->ddr3.m_delay[slice] << shift_val));
                  }
                break;
                case GATE:
                  {
                    uint32_t rdlvl_gate_reg_addr = DDR3_CTL_37 + ((slice + 2) / 4) * 4;
                                              /* The first rdlvl_gate register is in 3/4 high
                                                 portion of DDR3_CTL_37, hence the slice + 1 math */
                    uint32_t shift_val = ((slice + 2) % 4) << 3;

                    regval = HW_REGISTER (rdlvl_gate_reg_addr);
                    regval = regval & ~(0xfful << shift_val);
                    SET_HW_REGISTER (rdlvl_gate_reg_addr,
                                      regval | (phy_device->ddr3.m_delay[slice] << shift_val));
                  }
                break;
                default:
                  pretty_assert (0 && "invalid leveling_type_status");
              }
          count++;
        }
    }

  // if slices are still active, load the delays and wait until the responses come back
  if (count)
    nlm_device_ddr3_sw_lvl_load (phy_device);

  // Read the responses for all the slices which requested a response
  for (slice = 0; slice < phy_device->ddr3.m_max_slice; slice++)
    {
      if (phy_device->ddr3.m_request[slice] & GETREQ)
        {
          regval = ( (HW_REGISTER (DDR3_CTL_45 + 4 * (slice / 4)) ) >> ((slice % 4) * 8) ) & 0xff;
          if (phy_device->ddr3.leveling_type_status == READ)
            phy_device->ddr3.m_resp[slice] = (regval == 0xff || regval == 0) ? regval : VAL_X;
          else
            phy_device->ddr3.m_resp[slice] = regval;
        }
    }

  /* Perform refreshes periodically to prevent the simulator from timing out. Is it needed for FMS?
  if (count)
    checkRefresh ();
  */
}

//
// This task will get the logic response for the specified slice for the specified delay without
// considering the response values of the surrounding delays.  It is invoked by getResponse, which
// will use this response in combination with the surrounding responses to determine the final response.
// This task will first check to see if the response has already been read and saved, and if so, then
// the saved response will be retuned.  Or if the new delay matches the last delay read, then
// the previous response will be returned.  Otherwise, the new response will be read from the
// model.  The response will be read up to "retry_count" times, and if the results are a inconsistent
// an 'x' will be returned.  Otherwise, the consistent value will be returned.
//
static uint32_t
nlm_device_ddr3_get_request (nlm_phy_device_t *phy_device, uint32_t slice, uint32_t delay)
{
  uint32_t resp;
  int try;
  resp = VAL_Z;

  if (delay >= phy_device->ddr3.m_min_delay && delay <= phy_device->ddr3.m_max_delay)
    {
      if (phy_device->ddr3.m_save_responses && phy_device->ddr3.m_response[slice][delay] != VAL_Z)
        {
          // Return result which was previously read and saved
          resp = phy_device->ddr3.m_response[slice][delay];
        }
      else if (delay == phy_device->ddr3.m_delay[slice])
        {
          // Delay matches last delay, so return last response
          resp = phy_device->ddr3.m_resp[slice];
        }
      else
        {
          // Read the new response up to "retry_count" times.
          // Return an 'x' if any inconsistencies are detected.
          phy_device->ddr3.m_request[slice] = SETGETREQ;
          phy_device->ddr3.m_delay[slice] = delay;
          for (try = 0; try < phy_device->ddr3.m_retry_count && resp != VAL_X; try++)
            {
              nlm_device_ddr3_serial_send_receive (phy_device);
              phy_device->ddr3.m_request[slice] = GETREQ;
              if (resp == VAL_Z)
                {
                  resp = phy_device->ddr3.m_resp[slice];
                }
              else if (resp != phy_device->ddr3.m_resp[slice])
                {
                  resp = VAL_X;
                  phy_device->ddr3.m_resp[slice] = resp;
                }
            }
          if (phy_device->ddr3.m_save_responses)
            {
              phy_device->ddr3.m_response[slice][delay] = resp;
            }
        }
    }
  return (resp);
}

//
// This task will get the logic response for the specified slice for the specified delay.
// The response will be either '0', '1', 'x', or 'z'.  A 'z' is returned if the delay is
// out of range.  An 'x' is returned for any of the following reasons:
//   1. The memory model's "RANDOM_VS_X_READDATA" control variable is set to 0 so that it
//      returns an 'x' when the value read is not a definite '0' or '1'.  For example, an 'x'
//      is returned if the leveling delay timings produces setup and/or hold violations.
//   2. The response read for the specified delay is read "retry_count" times with inconsistent
//      results.  This happens when the memory model's "RANDOM_OUTPUT_DELAY" control variable is set
//      to a '0' and the resulting "jitter" produces inconsitent results in the transition regions.
//   3. The maximum number of responses with the same value for adjacent delays is less than
//      the number specified by the "jitter_range".  For example, if the jitter_range is 3, then
//      a value of '1' will only be returned for a delay of 8 if a value of '1' was also read
//      for either delays 6 and 7, 7 and 9, or 9 and 10.
// Otherwise, either a '0' or a '1' response is returned.
//
static uint32_t
nlm_device_ddr3_get_response (nlm_phy_device_t *phy_device, uint32_t slice, uint32_t delay)
{
  uint32_t resp;
  uint32_t count;
  uint32_t dn;
  uint32_t dp;
  uint32_t new_resp;

  resp = nlm_device_ddr3_get_request (phy_device, slice, delay);

  if (phy_device->ddr3.m_jitter_range > 1)
    {
      count = 1;
      dn = delay - 1;
      dp = delay + 1;
      while ((resp != VAL_X) && (count < phy_device->ddr3.m_jitter_range))
        {
          if (dn >= phy_device->ddr3.m_min_delay)
            {
              // Search for matching responses in the negative direction
              new_resp = nlm_device_ddr3_get_request (phy_device, slice, delay);
              if (resp == new_resp)
                {
                  // Response matches, so count it
                  count++;
                  dn--;
                }
              else
                  // Response doesn't match, so stop looking in negative direction
                  dn = phy_device->ddr3.m_min_delay - 1;
            }
          else if (dp <= phy_device->ddr3.m_max_delay)
            {
              // Search for matching responses in the positive direction
              new_resp = nlm_device_ddr3_get_request (phy_device, slice, delay);
              if (resp == new_resp)
                {
                  // Response matches, so count it
                  count++;
                  dp++;
                }
              else
                // Response doesn't match, so stop looking in positive direction
                dp = phy_device->ddr3.m_max_delay + 1;
            }
         else
// Couldn't find required number of matching adjacent responses, so convert this response to an 'x'
           resp = VAL_X;
        }
    }

  if (phy_device->ddr3.m_save_responses)
    phy_device->ddr3.m_response[slice][delay] = resp;

  return (resp);
}

//
// This task loads the specified delay for the specified slice without reading the response.
// It is called after leveling is complete to load the final computed delay.
// The request will only be made if the new delay does not equal the current delay.
//
static void
nlm_device_ddr3_set_request (nlm_phy_device_t *phy_device, uint32_t slice, uint32_t delay)
{
  if (delay != phy_device->ddr3.m_delay[slice])
    {
      phy_device->ddr3.m_request[slice] = SETREQ;
      phy_device->ddr3.m_delay[slice] = delay;
      nlm_device_ddr3_serial_send_receive (phy_device);
    }
}

static void
nlm_device_ddr3_calc_delays (nlm_phy_device_t *phy_device, uint32_t slice,
                              uint32_t last_delay[], uint32_t *startVal)
{
  int32_t delay;
  switch (phy_device->ddr3.leveling_type_status)
    {
      case WRITE:
        {
          if (*startVal == SX1)
            delay = last_delay[SX1] / 2;
          else
            delay = (last_delay[S0X] + last_delay[SX1]) / 2;
          // Load the final delay values
          nlm_device_ddr3_set_request (phy_device, slice, delay);
        }
      break;
      case READ:
        //
        // Calculate the delay based on the initial value read for delay zero.
        // If we stared with an initial response of zero, then find the first 0 -> 1 transition
        // and subtract the delay equivalent to a quarter of a cycle.  Otherwise, find the
        // delays corresponding to the X->0 and 0->X and calculate the delay for the midpoint.
        //
        {
          uint32_t regval;
          uint32_t regval1;
          // Wait until read leveling is complete for both the positive and the negative clock edges
          if (phy_device->ddr3.shift == 0)
            {
              // Calculate the delay for the positive clock edge
              if (startVal == S0X)
                {
                  delay = (((last_delay[S0X] + last_delay[SX1]) / 2)
                              + phy_device->ddr3.tdqsq_delay - 24) / 2;
                  regval = delay < 0 ? 0 : delay;
                }
              else
                regval = (last_delay[S0X] + last_delay[SX0]) / 2;
              // Calculate the delay for the negative clock edge
              if (phy_device->ddr3.m_rdlvl_startVal[1][slice] == S0X)
                {
                  delay = (phy_device->ddr3.m_rdlvl_delay[1][slice][S0X]
                            + phy_device->ddr3.tdqsq_delay - 24) / 2;
                  regval1 = delay < 0 ? 0 : delay;
                }
              else
                regval1 = (phy_device->ddr3.m_rdlvl_delay[1][slice][S0X]
                            + phy_device->ddr3.m_rdlvl_delay[1][slice][SX0]) / 2;
              // Load the final delay values
              regval += regval1 << 8;
              nlm_device_ddr3_set_request (phy_device, slice, regval);
            }
        }
      break;
      case GATE:
        //
        // If we are leveling and we didn't open the gate in the preamble, then we need to
        // find the preamble by centering the gate open in a plus and subtracting full cycle
        // delays until we detect a zero.  If we are tuning or we opened the gate in the
        // preamble, then all we need to do is remove a half cycle of delay to center the
        // gate open in the preamble.
        //
        {
          uint32_t success = 1;
          uint32_t resp;

          if (phy_device->ddr3.m_gtlvl_is_leveled || phy_device->ddr3.m_in_preamble)
            // Center the gate open in the preamble
            success = nlm_device_ddr3_decr_half_cycle_delay (phy_device, slice);
          else
            {
              // Center the gate open on a pulse
              delay = (last_delay[SX1] + last_delay[S1X]) / 2;
              resp = nlm_device_ddr3_get_response (phy_device, slice, delay);
              // Search backwards for the preamble
              while (resp != 0 && success)
                {
                  success = nlm_device_ddr3_decr_full_cycle_delay (phy_device, slice);
                  resp = nlm_device_ddr3_get_response (phy_device, slice, delay);
                }
              // Center the gate open in the preamble
              success = nlm_device_ddr3_incr_half_cycle_delay (phy_device, slice);
            }
          // Load the final delay values
          delay = (last_delay[S0X] + last_delay[SX1]) / 2;
          nlm_device_ddr3_set_request (phy_device, slice, delay);
        }
      break;
      default:
        pretty_assert (0 && "invalid leveling_type_status");
    }
}
//
// This task performs the tuning for each slice.  It first determines which
// edges to tune by calling nlm_device_ddr3_get_edges with the original leveling startVal
// transition.  It then searches for each edge starting with the last delay
// that corresponded to that edge.  Once all the edges are found, the
// CalcDelay routine is called to compute and load the newly tuned delay value.
//
static nlm_status
nlm_device_ddr3_tune_edge (nlm_phy_device_t *phy_device, uint32_t slice,
                            uint32_t last_delay[], uint32_t *startVal /* in/out */)
{
  uint32_t reset = 0;
  uint32_t edges_size;
  uint32_t i;
  uint32_t delay;                    // current delay value of this slice
  uint32_t resp;                     // all of the response bits or'ed together
  uint32_t resp1;                    // all of the response bits or'ed together
  uint32_t resp2;                    // all of the response bits or'ed together
  uint32_t idx;                      // current value idx
  uint32_t last;                     // last delay where response > edge

  nlm_device_ddr3_init_response (phy_device, slice);

  // Determine which edges we are searching for
  edges_size = nlm_device_ddr3_get_edges (phy_device, slice, *startVal, &reset);

  // Tune each of the requested edges
  for (i = 0; i < edges_size; i++)
    {
      // Get the idx and responses for the next edge
      idx = phy_device->ddr3.edges[i];
      switch (idx)
        {
        case S0X:
          {
            resp1 = 0;
            resp2 = VAL_X;
            break;
          }
        case S1X:
          {
            resp1 = 1;
            resp2 = VAL_X;
            break;
          }
        case SX0:
          {
            resp1 = VAL_X;
            resp2 = 0;
            break;
          }
        case SX1:
          {
            resp1 = VAL_X;
            resp2 = 1;
            break;
          }
        }

      // Start with the last known delay for this edge and get the response
      delay = (last_delay[idx] > 1) ? (last_delay[idx] - 1) : 0;
      resp = nlm_device_ddr3_get_response (phy_device, slice, delay);

      if (resp == resp1 || (resp1 == VAL_X && resp != resp2))
        {
          // The current response corresponds to resp1, so search for resp2 by incrementing the delay
          while (resp == resp1 || (resp1 == VAL_X && resp != resp2))
            {
              delay++;
              if (delay > phy_device->ddr3.m_max_delay)
                {
                  delay = phy_device->ddr3.m_max_delay;
                  resp = resp2;
                  return NLM_DDR3_TUNING_MAX_DELAY_REACHED;
                }
              else
                resp = nlm_device_ddr3_get_response (phy_device, slice, delay);
            }
          last_delay[idx] = delay;
        }
      else
        {
          // The current response corresponds to resp2, so search for resp1 by decrementing the delay
          while (!(resp == resp1 || (resp1 == VAL_X && resp != resp2)))
            {
              last = delay--;
              if (delay < phy_device->ddr3.m_min_delay)
                {
                  /*  Decided not to warn about this condition
                  printf ("WARNING: %s: Software Tuning ended with minimum delay for slice %0d",
                          phy_device->ddr3.leveling_type_status, slice);
                  */
                  delay = phy_device->ddr3.m_min_delay;
                  resp = resp1;
                }
              else
                resp = nlm_device_ddr3_get_response (phy_device, slice, delay);
            }
          last_delay[idx] = last;
        }
    }

  // Calculate and load the final delay based on all the newly tuned edges
  nlm_device_ddr3_calc_delays (phy_device, slice, last_delay, startVal);

  phy_device->ddr3.m_request[slice] = TERMREQ;
  return NLM_OK;
}

//
// This task will search a range of delays which contains a transition and
// determine the exact delay where the transition occurred.  The search will
// only take place if the edge is the next edge we are searching for.  A
// binary search is used to locate the edge.  The delay corresponding to the
// edge is returned in the last_delay variable.  The min and max values
// for the region searched are also returned to increase the efficiencies of
// any subsequent searches.
//
static void
nlm_device_ddr3_trans_edge (nlm_phy_device_t *phy_device, uint32_t slice, uint32_t edges_size,
                            uint32_t last_delay[], uint32_t resp1, uint32_t resp2,
                            int32_t *idx, uint32_t *min, uint32_t *max)
{
  int delay;
  int resp;
  ddr3_leveling_transition trans;
  int last = *max;

  if (*idx >= 0)
    {
      // Determine which edge we have found
      if (resp1 != VAL_X)
        trans = (resp1 == 0) ? S0X : S1X;
      else
        trans = (resp2 == 0) ? SX0 : SX1;

      // Check to see if this is the next edge we are trying to fine
      if (trans == phy_device->ddr3.edges[*idx])
        {
          while ((*max - *min) > 1)
            {
              delay = (*min + *max) >> 1;
              resp = nlm_device_ddr3_get_response (phy_device, slice, delay);
              // Reduce the search range based on the value of the response
              if (resp == resp1 || (resp1 == VAL_X && resp != resp2))
                *min = delay;
              else
                *max = delay;
            }
          last_delay[trans] = *max;
          *max = last;
          *idx = *idx + 1;
        }
    }
}

//
// This task preforms the initial leveling for each slice.  It starts with a
// delay of 0 and searches for the first transition (S0X, S1X, SX0, or SX1).
// The first transition is used by nlm_device_ddr3_get_edges to determine the number, order,
// and count of the edges to be found.  The corresponding delay for each edge
// is determine by the nlm_device_ddr3_trans_edge routine which searches the range where the
// transition occured and finds the exact delay which corresponds to the edge.
// Note that a transition from 0 to 1 is considered to be an S0X edge followed
// by a SX1 edge and a transition from 1 to 0 is considered to be an S1X edge
// followed by a SX0 edge.  Once all the edges are found, the calcDelay rountine
// is called to compute and load the final delay value to level the slice.
//
static nlm_status
nlm_device_ddr3_find_edge (nlm_phy_device_t *phy_device, uint32_t slice, uint32_t last_delay[],
                            uint32_t *startVal /* in/out */)
{
  uint32_t reset = 1;                 // set if we need to reset search
  uint32_t edges_size = 0;
  uint32_t delay;                    // current delay value of this slice
  uint32_t resp1;                    // all of the response bits or'ed together
  uint32_t resp2;                    // all of the response bits or'ed together
  int32_t idx = -1;                  // idx of current value
  uint32_t min;                      // last delay where response < edge
  uint32_t max;                      // last delay where response < edge

  nlm_device_ddr3_init_response (phy_device, slice);

  // Search until all the edges are found.
  // The edges_size will become nonzero once the first edge is found.
  while (idx < edges_size)
    {
      if (reset)
        {
          reset = 0;
          delay = phy_device->ddr3.m_min_delay;
          resp1 = nlm_device_ddr3_get_response (phy_device, slice, delay);
        }
      min = delay;
      delay += phy_device->ddr3.m_step_size;
      if (delay > phy_device->ddr3.m_max_delay)
        {
          delay = phy_device->ddr3.m_max_delay;
          // Handle condition where we are still looking when the delay hits the maximum
          if (min == phy_device->ddr3.m_max_delay)
            {
              resp1 = resp2;
              idx = 100;
              return NLM_DDR3_LEVELING_MAX_DELAY_REACHED;
            }
          else
            {
              resp2 = nlm_device_ddr3_get_response (phy_device, slice, delay);
            }
        }
      else
        {
          resp2 = nlm_device_ddr3_get_response (phy_device, slice, delay);
        }
      // If the response has changed, we have found an edge
      if (resp1 != resp2)
        {
          // If this is the first edge, set the startVal and call
          // nlm_device_ddr3_get_edges to determine what edges we will be searching for.
          if (idx == -1)
            {
              if (resp1 != VAL_X)
                *startVal = (resp1 == 0) ? S0X : S1X;
              else
                *startVal = (resp2 == 0) ? SX0 : SX1;

              edges_size = nlm_device_ddr3_get_edges (phy_device, slice, *startVal, &reset);
              idx = 0;
            }
          if (!reset)
            {
              max = delay;
              if (resp1 != VAL_X && resp2 != VAL_X)
                {
                  // if neither response is an 'x', break the transition into two edges
                  nlm_device_ddr3_trans_edge (phy_device, slice, edges_size, last_delay, resp1,
                                              VAL_X, &idx, &min, &max);
                  nlm_device_ddr3_trans_edge (phy_device, slice, edges_size, last_delay, VAL_X,
                                              resp2, &idx, &min, &max);
                }
              else
                {
                  // Process the transition for a single edge.
                  nlm_device_ddr3_trans_edge (phy_device, slice, edges_size, last_delay, resp1,
                                              resp2, &idx, &min, &max);
                }
              resp1 = resp2;
            }
        }
    }

  // Calculate and load the final delay based on all the edges found
  nlm_device_ddr3_calc_delays (phy_device, slice, last_delay, startVal);

  // Leveling is done, so tell the parent we are terminating.
  phy_device->ddr3.m_request[slice] = TERMREQ;
  return NLM_OK;
}

//
// This is the parent task which is responsible for ensuring that all the slices get
// leveled or tuned.  It will fork off a task for each active slice which invokes
// either "nlm_device_ddr3_tune_edge" for tuning or "nlm_device_ddr3_find_edge" for leveling.  After the fork, it
// services the requests from each child for either loading a delay (SETREQ),
// reading the response for a previously loaded delay (GETREQ), or both loading a
// delay and reading the response.  The parent waits until all the active slices are
// ready before reading a response so that all the responses can be read in parallel.
// This is because reading a response is takes a relatively long time, and the model
// always reads all the responses for each request.  This parent will continue setting
// delays and reading responses until it receives a terminate requests (TERMREQ) from
// each of the active slice.
//
// Note: In this translated program, all tasks will happen serially.  There will be no
// forks since each task must complete before another is initiated.
//
static nlm_status
nlm_device_ddr3_level_edges (nlm_phy_device_t *phy_device, uint32_t request,
                              uint32_t last_delay[NLM_DDR3_MAX_SLICE][NLM_DDR3_MAX_SLICE_SUB],
                              uint32_t startVal[NLM_DDR3_MAX_SLICE])
{
  uint32_t slice;

  for (slice = 0; slice < phy_device->ddr3.m_max_slice; slice++)
    if ((request & (1 << slice)) != 0)
      {
        if (phy_device->ddr3.leveling_type_status)
          TRY (nlm_device_ddr3_tune_edge (phy_device, slice, last_delay[slice], &startVal[slice]))
        else
          TRY (nlm_device_ddr3_find_edge (phy_device, slice, last_delay[slice], &startVal[slice]))
      }
  return NLM_OK;
}


//
// Perform the write leveling setup and then call levelEdges to perform the leveling
//
static void
nlm_device_ddr3_do_level_mc_write (nlm_phy_device_t *phy_device, uint32_t req)
{
  SET_HW_REGISTER_FIELD (DDR3_CTL_48, ddr3_ctl_48, tdfi_wrlvl_resplat, 8);

  // Compute maximum gate leveling delay
  if (phy_device->ddr3.dll_is_macro)
    phy_device->ddr3.m_max_delay = 0xc2; //NOTE: hardcoded value to match simulation results
                                     //TODO: Make sure this works for the real life.
  else
    phy_device->ddr3.m_max_delay = (1 << DLL_DQS_DELAY_WIDTH) - 1;

  // Determine the delay of the edge
  nlm_device_ddr3_level_edges (phy_device, req, phy_device->ddr3.m_wrlvl_delay,
                                            phy_device->ddr3.m_wrlvl_startVal);
}

//
// Set the read delay to the specified value
//
static void
nlm_device_ddr3_set_read_delay (nlm_phy_device_t *phy_device, uint32_t slice, uint32_t value)
{
  pretty_assert ((value < 8) && (value >= 0) && "Calculated read data value is out of range (0-7)");
  if (((phy_device->ddr3.m_phy_ctrl_0[slice] >> 24) & 7) != value)
    {
      phy_device->ddr3.m_phy_ctrl_0[slice]
        = (phy_device->ddr3.m_phy_ctrl_0[slice] & ~(7 << 24)) | ((value & 7) << 24);
      SET_HW_REGISTER (DDR3_CTL_81 + slice, phy_device->ddr3.m_phy_ctrl_0[slice]);
    }
}

//
// Perform the gate training setup an then call levelEdges to perform the leveling
//
static void
nlm_device_ddr3_do_level_mc_gate (nlm_phy_device_t *phy_device, uint32_t req)
{
  int success;
  int rd_offset = 0;
  int rd_data = 0;
  int round_trip;
  int slice;

  SET_HW_REGISTER_FIELD (DDR3_CTL_48, ddr3_ctl_48, tdfi_rdlvl_rr, 0x10);
  SET_HW_REGISTER_FIELD (DDR3_CTL_47, ddr3_ctl_47, tdfi_rdlvl_resplat, 18);
  SET_HW_REGISTER_FIELD (DDR3_CTL_27, ddr3_ctl_27, tdfi_rddata_en_base, 0);
  SET_HW_REGISTER_FIELD (DDR3_CTL_26, ddr3_ctl_26, rdlat_adj, 7);

  // Compute maximum gate leveling delay
  phy_device->ddr3.m_max_delay = (1 << NLM_DDR3_DLL_DQS_DELAY_WIDTH) - 1;

  // Calculate the round trip delay constant used to compute the read delay value for each slice
  if (!phy_device->ddr3.m_gtlvl_is_leveled)
    {
      int factor = 10;
      int offset = 0;
      int caslat = 0;
      //NOTE: hardcoded to match simulation vector
      HW_REGISTER_FIELD (DDR3_CTL_27, ddr3_ctl_27, tdfi_rddata_en_base, rd_data);
      round_trip = (NLM_DDR3_OUT_PAD_DELAY * factor) +
        (NLM_DDR3_IN_PAD_DELAY * factor) + ((NLM_DDR3_FLIGHT_DELAY * factor) * 2)
          + NLM_DDR3_TDQSCK_MAX;
      //NOTE: hardcoded to match simulation vector
      HW_REGISTER_FIELD (DDR3_CTL_25, ddr3_ctl_25, caslat_lin, caslat);
      rd_offset = offset + (caslat >> 2) + (phy_device->ddr3.m_fast ? 0 : 1);
    }

  // Calculate and load the read delay value for each slice
  // Calculate and load the correct full and half cycle shift values based on
  // whether or not the gate needs to open in the preamble.
  for (slice = 0; slice < phy_device->ddr3.m_max_slice; slice++)
    {
      if (req & (1 << slice))
        {
          if (!phy_device->ddr3.m_gtlvl_is_leveled)
            {
              int data_delay = phy_device->ddr3.m_data_delay[phy_device->ddr3.m_cs_rank][slice];
              int ctrl_delay = phy_device->ddr3.m_ctrl_delay[phy_device->ddr3.m_cs_rank][slice];
              int delta;
              int rd_dly =
                rd_offset + rd_data
                    + ((round_trip + data_delay + ctrl_delay + phy_device->ddr3.sim_ps_period - 1)
                      / phy_device->ddr3.sim_ps_period);
              if (!phy_device->ddr3.m_in_preamble)
                delta = 5;
              else if (phy_device->ddr3.m_is_gatesim)
                delta =
                  (((data_delay << 1) + (phy_device->ddr3.sim_ps_period >> 2) +
                    (phy_device->ddr3.sim_ps_period >> 3)) / (phy_device->ddr3.sim_ps_period >> 1));
              else
                delta = (((data_delay << 1) + (phy_device->ddr3.sim_ps_period >> 2))
                  / (phy_device->ddr3.sim_ps_period >> 1));

              delta += (phy_device->ddr3.m_is_gatesim) ? 1 : 2;
              nlm_device_ddr3_set_read_delay (phy_device, slice, rd_dly);
              nlm_device_ddr3_set_full_cycle_delay (phy_device, slice, rd_data + (delta >> 1));
              if (delta & 1)
                success = nlm_device_ddr3_incr_half_cycle_delay (phy_device, slice);
            }
          else
            success = nlm_device_ddr3_incr_half_cycle_delay (phy_device, slice);
        }
    }

  // Determine the delay of the edges
  nlm_device_ddr3_level_edges (phy_device, req,
                                phy_device->ddr3.m_gtlvl_delay, phy_device->ddr3.m_gtlvl_startVal);
}

//
// Perform the read leveling setup an then call levelEdges to perform the leveling
//
static void
nlm_device_ddr3_do_level_mc_read (nlm_phy_device_t *phy_device, uint32_t req)
{
  int pn_edge;

  SET_HW_REGISTER_FIELD (DDR3_CTL_48, ddr3_ctl_48, tdfi_rdlvl_rr, 0x10);
  SET_HW_REGISTER_FIELD (DDR3_CTL_47, ddr3_ctl_47, tdfi_rdlvl_resplat, 18);

  phy_device->ddr3.m_max_delay = (1 << DLL_DQS_DELAY_WIDTH) - 1;

  phy_device->ddr3.tdqsq_delay = ((NLM_DDR3_TDQSQ * (phy_device->ddr3.m_dll_ctrl_0[0] & 255))
    / phy_device->ddr3.sim_ps_period);


  // Read Level on both the positive and the negative edge of the clock
  for (pn_edge = 1; pn_edge >= 0; pn_edge--)
    {
      SET_HW_REGISTER_FIELD (DDR3_CTL_06, ddr3_ctl_06, rdlvl_edge, pn_edge);
      phy_device->ddr3.shift = 8 * pn_edge;
      nlm_device_ddr3_level_edges (phy_device, req, phy_device->ddr3.m_rdlvl_delay[pn_edge],
                                                phy_device->ddr3.m_rdlvl_startVal[pn_edge]);
    }
}


//
// Wait for the operation to complete.
// Generate an error if the operation doesn't complete in a timely manner.
//
static void
nlm_device_ddr3_wait_op_done (nlm_phy_device_t *phy_device)
{
  union ddr3_ctl_12 reg12;
  int i;

  for (i = 0; i < DDR3_OP_TIMEOUT; i++)
    {
      reg12.word32 = HW_REGISTER (DDR3_CTL_12);
      if (reg12.s.swlvl_op_done)
        return;
    }

  pretty_assert (reg12.s.swlvl_op_done && "DDR3 timeout waiting for op_done");
}

//
// Request to load the programmed delays and wait for the response.
//
static void
nlm_device_ddr3_sw_lvl_load (nlm_phy_device_t *phy_device)
{
  union ddr3_ctl_11 reg11;

  reg11.word32 = HW_REGISTER (DDR3_CTL_12);
  reg11.s.swlvl_load = 1;
  SET_HW_REGISTER (DDR3_CTL_12, reg11.word32);
  nlm_device_ddr3_wait_op_done (phy_device);
}

//
// Request to exit leveling mode.
// The controller will perform the necessary MSR register writes to exit leveling mode.
//
static void
nlm_device_ddr3_sw_lvl_exit (nlm_phy_device_t *phy_device)
{
  union ddr3_ctl_11 reg11;

  reg11.word32 = HW_REGISTER (DDR3_CTL_12);
  reg11.s.swlvl_exit = 1;
  SET_HW_REGISTER (DDR3_CTL_12, reg11.word32);
  nlm_device_ddr3_wait_op_done (phy_device);
}

//
// Set the leveling mode and the start bit.
// The controller will perform the necessary MSR register writes to put us in leveling mode.
//
static void
nlm_device_ddr3_sw_lvl_start (nlm_phy_device_t *phy_device)
{
  union ddr3_ctl_17 reg17;
  union ddr3_ctl_12 reg12;

  // Set software leveling mode
  reg17.word32 = HW_REGISTER (DDR3_CTL_17);
  reg17.s.sw_leveling_mode = phy_device->ddr3.leveling_type_status;
  SET_HW_REGISTER (DDR3_CTL_17, reg17.word32);

  // Set leveling start bit
  reg12.word32 = HW_REGISTER (DDR3_CTL_12);
  reg12.s.swlvl_start = 1;
  SET_HW_REGISTER (DDR3_CTL_12, reg12.word32);

  nlm_device_ddr3_wait_op_done (phy_device);
}

//
// Task used for first pass initialization of leveling routines
//
static void
nlm_device_ddr3_init_leveling (nlm_phy_device_t *phy_device)
{
  int m_is_delay = 0;
  int m_cs_rank = -1;
  int slice;
  int cs;

  // Determine how many data slices are present and setup enables
  phy_device->ddr3.m_max_slice = NLM_DDR3_MEM_DQS_WIDTH + NLM_DDR3_MEM_ECC_DQS_WIDTH;

  phy_device->ddr3.m_valid = (1 << phy_device->ddr3.m_max_slice) - 1;


  for (cs = NLM_DDR3_MAX_CS - 1; (cs >= 0) && (m_is_delay == 0); cs--)
    if ((NLM_DDR3_CS_MAP & (1 << cs)) || (NLM_DDR3_MAX_CS == 1))
      for (slice = 0; (slice < phy_device->ddr3.m_max_slice) && (m_is_delay == 0); slice++)
        if ((phy_device->ddr3.m_valid >> slice) & 1)
          {
            m_cs_rank = cs;
            if ((phy_device->ddr3.m_data_delay[cs][slice] != 0)
                  || (phy_device->ddr3.m_ctrl_delay[cs][slice] != 0))
              m_is_delay = 1;
          }
}

#if 0
//
// This task is invoked by the bodies of the Write Leveing, Gate Training, and Read
// Leveling classes to perform the leveling.  The first time any of these classes
// invoke this task, it configures itself by determining the number of active slices
// and how many of these slices have non-zero memory delays.  No leveling is
// performed unless at least one of the active slices has a non-zero fly-by delay.
// The memory model may be set up to produce random output delays and to return
// only '0's and '1's instead of 'x's.  The memory model setup is used to determine
// the values of various variables which control the leveling algorithm such as
// retry_count, jitter_range, and step_size.  The level_in_parallel control variable
// determines whether the slices are to be leveled serially or in parallel.
//
// Note: this translation does not support parallel leveling.
//
static void
nlm_device_ddr3_do_leveling (nlm_phy_device_t *phy_device, int32_t *swhw, uint32_t *is_leveled)
{
  uint32_t dfi_swhw;
  uint32_t slice;
  uint32_t req;

  if (*swhw == -1)
    dfi_swhw = 0;
  else
    dfi_swhw = *swhw;

  *swhw = dfi_swhw;

  // Reusing dfi_swhw for the register value
  if ((dfi_swhw == 1) && (*is_leveled == 0))
    dfi_swhw = 0;

  switch (phy_device->ddr3.leveling_type_status)
    {
      case WRITE:
        SET_HW_REGISTER_FIELD (DDR3_CTL_24, ddr3_ctl_24, tdfi_wrlvl_en, dfi_swhw);
      break;
      case READ:
        SET_HW_REGISTER_FIELD (DDR3_CTL_07, ddr3_ctl_07, rdlvl_en, dfi_swhw);
      break;
      case GATE:
        SET_HW_REGISTER_FIELD (DDR3_CTL_07, ddr3_ctl_07, rdlvl_gate_en, dfi_swhw);
      break;
      default:
        pretty_assert (0 && "invalid leveling_type_status");
    }

  if (phy_device->ddr3.m_max_slice == 0)      // For first pass initialization only
    nlm_device_ddr3_init_leveling (phy_device);

  phy_device->ddr3.m_step_size = 8;       // coarse delay increment
  phy_device->ddr3.m_jitter_range = 1;    // range required for consistent response
  phy_device->ddr3.m_retry_count = 5;     // number of times to reread a response
  phy_device->ddr3.m_save_responses = 1;  // Save the responses to keep from rereading them

  // Select the chip select of the highest enabled CS rank which has delays
  switch (phy_device->ddr3.leveling_type_status)
    {
      case WRITE:
        SET_HW_REGISTER_FIELD (DDR3_CTL_13, ddr3_ctl_13, wrlvl_cs, phy_device->ddr3.m_cs_rank);
      break;
      case READ:
        SET_HW_REGISTER_FIELD (DDR3_CTL_06, ddr3_ctl_06, rdlvl_cs, phy_device->ddr3.m_cs_rank);
      break;
      case GATE:
        SET_HW_REGISTER_FIELD (DDR3_CTL_06, ddr3_ctl_06, rdlvl_cs, phy_device->ddr3.m_cs_rank);
      break;
      default:
        pretty_assert (0 && "invalid leveling_type_status");
    }

/*
  // Initial leveling may take time, so force some refreshes first
  if (!*is_leveled)
    doRefresh (50);
*/

  // Put the model in leveling mode
  nlm_device_ddr3_sw_lvl_start (phy_device);

  // Level all slices in MC Eval mode one at a time
  for (slice = 0; slice < phy_device->ddr3.m_max_slice; slice++)
    if ((phy_device->ddr3.m_valid >> slice) & 1)
      {
        req = 1 << slice;
        // nlm_device_ddr3_do_level_mc (phy_device, req);
      }

  // Exit leveling mode
  nlm_device_ddr3_sw_lvl_exit (phy_device);

  *is_leveled = 1;
}
#endif

static void
nlm_device_ddr3_do_leveling_write (nlm_phy_device_t *phy_device)
{
  uint32_t dfi_swhw;
  uint32_t slice;
  uint32_t req;

  phy_device->ddr3.leveling_type_status = WRITE;

  if (phy_device->ddr3.m_wrlvl_swhw == -1)
    dfi_swhw = 0;
  else
    dfi_swhw = phy_device->ddr3.m_wrlvl_swhw;

  phy_device->ddr3.m_wrlvl_swhw = dfi_swhw;

  // Reusing dfi_swhw for the register value
  if ((dfi_swhw == 1) && (phy_device->ddr3.m_wrlvl_is_leveled == 0))
    dfi_swhw = 0;

  SET_HW_REGISTER_FIELD (DDR3_CTL_24, ddr3_ctl_24, tdfi_wrlvl_en, dfi_swhw);

  if (phy_device->ddr3.m_max_slice == 0)      // For first pass initialization only
    nlm_device_ddr3_init_leveling (phy_device);

  phy_device->ddr3.m_step_size = 8;       // coarse delay increment
  phy_device->ddr3.m_jitter_range = 1;    // range required for consistent response
  phy_device->ddr3.m_retry_count = 5;     // number of times to reread a response
  phy_device->ddr3.m_save_responses = 1;  // Save the responses to keep from rereading them

  // Select the chip select of the highest enabled CS rank which has delays
  SET_HW_REGISTER_FIELD (DDR3_CTL_13, ddr3_ctl_13, wrlvl_cs, phy_device->ddr3.m_cs_rank);

/*
  // Initial leveling may take time, so force some refreshes first
  if (!*is_leveled)
    doRefresh (50);
*/

  // Put the model in leveling mode
  nlm_device_ddr3_sw_lvl_start (phy_device);

  // Level all slices in MC Eval mode one at a time
  for (slice = 0; slice < phy_device->ddr3.m_max_slice; slice++)
    {
      if ((phy_device->ddr3.m_valid >> slice) & 1)
        {
          req = 1 << slice;
          nlm_device_ddr3_do_level_mc_write (phy_device, req);
        }
    }

  // Exit leveling mode
  nlm_device_ddr3_sw_lvl_exit (phy_device);

  phy_device->ddr3.m_wrlvl_is_leveled = 1;
}

static void
nlm_device_ddr3_do_leveling_gate (nlm_phy_device_t *phy_device)
{
  uint32_t dfi_swhw;
  uint32_t slice;
  uint32_t req;

  phy_device->ddr3.leveling_type_status = GATE;

  if (phy_device->ddr3.m_gtlvl_swhw == -1)
    dfi_swhw = 0;
  else
    dfi_swhw = phy_device->ddr3.m_gtlvl_swhw;

  phy_device->ddr3.m_gtlvl_swhw = dfi_swhw;

  // Reusing dfi_swhw for the register value
  if ((dfi_swhw == 1) && (phy_device->ddr3.m_gtlvl_is_leveled == 0))
    dfi_swhw = 0;

  SET_HW_REGISTER_FIELD (DDR3_CTL_07, ddr3_ctl_07, rdlvl_gate_en, dfi_swhw);

  if (phy_device->ddr3.m_max_slice == 0)      // For first pass initialization only
    nlm_device_ddr3_init_leveling (phy_device);

  phy_device->ddr3.m_step_size = 8;       // coarse delay increment
  phy_device->ddr3.m_jitter_range = 1;    // range required for consistent response
  phy_device->ddr3.m_retry_count = 5;     // number of times to reread a response
  phy_device->ddr3.m_save_responses = 1;  // Save the responses to keep from rereading them

  // Select the chip select of the highest enabled CS rank which has delays
  SET_HW_REGISTER_FIELD (DDR3_CTL_06, ddr3_ctl_06, rdlvl_cs, phy_device->ddr3.m_cs_rank);

/*
  // Initial leveling may take time, so force some refreshes first
  if (!*is_leveled)
    doRefresh (50);
*/

  // Put the model in leveling mode
  nlm_device_ddr3_sw_lvl_start (phy_device);

  // Level all slices in MC Eval mode one at a time
  for (slice = 0; slice < phy_device->ddr3.m_max_slice; slice++)
    {
      if ((phy_device->ddr3.m_valid >> slice) & 1)
        {
          req = 1 << slice;
          nlm_device_ddr3_do_level_mc_gate (phy_device, req);
        }
    }

  // Exit leveling mode
  nlm_device_ddr3_sw_lvl_exit (phy_device);

  phy_device->ddr3.m_gtlvl_is_leveled = 1;
}

static void
nlm_device_ddr3_do_leveling_read (nlm_phy_device_t *phy_device)
{
  uint32_t dfi_swhw;
  uint32_t slice;
  uint32_t req;

  phy_device->ddr3.leveling_type_status = READ;

  if (phy_device->ddr3.m_rdlvl_swhw == -1)
    dfi_swhw = 0;
  else
    dfi_swhw = phy_device->ddr3.m_rdlvl_swhw;

  phy_device->ddr3.m_rdlvl_swhw = dfi_swhw;

  // Reusing dfi_swhw for the register value
  if ((dfi_swhw == 1) && (phy_device->ddr3.m_rdlvl_is_leveled == 0))
    dfi_swhw = 0;

  SET_HW_REGISTER_FIELD (DDR3_CTL_07, ddr3_ctl_07, rdlvl_en, dfi_swhw);

  if (phy_device->ddr3.m_max_slice == 0)      // For first pass initialization only
    nlm_device_ddr3_init_leveling (phy_device);

  phy_device->ddr3.m_step_size = 8;       // coarse delay increment
  phy_device->ddr3.m_jitter_range = 1;    // range required for consistent response
  phy_device->ddr3.m_retry_count = 5;     // number of times to reread a response
  phy_device->ddr3.m_save_responses = 1;  // Save the responses to keep from rereading them

  // Select the chip select of the highest enabled CS rank which has delays
  SET_HW_REGISTER_FIELD (DDR3_CTL_06, ddr3_ctl_06, rdlvl_cs, phy_device->ddr3.m_cs_rank);

/*
  // Initial leveling may take time, so force some refreshes first
  if (!*is_leveled)
    doRefresh (50);
*/

  // Put the model in leveling mode
  nlm_device_ddr3_sw_lvl_start (phy_device);

  // Level all slices in MC Eval mode one at a time
  for (slice = 0; slice < phy_device->ddr3.m_max_slice; slice++)
    {
      if ((phy_device->ddr3.m_valid >> slice) & 1)
        {
          req = 1 << slice;
          nlm_device_ddr3_do_level_mc_read (phy_device, req);
        }
    }

  // Exit leveling mode
  nlm_device_ddr3_sw_lvl_exit (phy_device);

  phy_device->ddr3.m_rdlvl_is_leveled = 1;
}


static nlm_status
nlm_device_ddr3_train (nlm_phy_device_t *phy_device)
{

  /* The leveling task consists of three steps */

  nlm_device_ddr3_do_leveling_write (phy_device);
  nlm_device_ddr3_do_leveling_gate (phy_device);
  nlm_device_ddr3_do_leveling_read (phy_device);

  /* For some reason the original code had these three times */

  return NLM_OK;
}

void
nlm_device_copy_into_ddr (nlm_phy_device_t *phy_device, nlm_phys_addr ddr_addr, uint32_t byte_cnt)
{
#ifdef NO_DMA_FOR_DDR
  uint64_t addr;
  uint32_t i;

  MEMORY_BARRIER ();

  ddr_addr &= ~(1ull << 61);
  NLM_SPIN_LOCK (&phy_device->ddr_dma_area_lock);
  for ( addr = ddr_addr, i = 0;
        addr < ddr_addr + byte_cnt * sizeof (uint32_t);
        addr += 4, i++)
    {
      nlm_device_ddr_write_ind_32 (phy_device, addr, ((uint32_t*)phy_device->ddr_dma_area)[i]);
    }
#else
  nlm_phys_addr host_phys_addr = CONVERT_TO_PHYSICAL (phy_device->ddr_dma_area);

  MEMORY_BARRIER ();

  /* 61-st bit of addr should be set to indicate DDR */
  pretty_assert (ddr_addr & (1ull << 61));

  /* DMA engine support only 2**24 byte transfers */
  pretty_assert ((byte_cnt >> 24) == 0 && byte_cnt != 0);

  NLM_SPIN_LOCK (&phy_device->ddr_dma_area_lock);
  DPRINT ("DDR_DMA_SRC_ADDR_LO 0x%08x\n", (uint32_t) (host_phys_addr));
  DPRINT ("DDR_DMA_SRC_ADDR_HI 0x%08x\n", (uint32_t) (host_phys_addr >> 32));
  DPRINT ("DDR_DMA_DST_ADDR_LO 0x%08x\n", (uint32_t) (ddr_addr));
  DPRINT ("DDR_DMA_DST_ADDR_HI 0x%08x\n", (uint32_t) (ddr_addr >> 32));
  DPRINT ("DDR_DMA_CTRL 0x%08x\n", (byte_cnt | 0x80000000));

  SET_HW_REGISTER (DDR_DMA_SRC_ADDR_LO, (uint32_t) (host_phys_addr));
  SET_HW_REGISTER (DDR_DMA_SRC_ADDR_HI, (uint32_t) (host_phys_addr >> 32));
  SET_HW_REGISTER (DDR_DMA_DST_ADDR_LO, (uint32_t) (ddr_addr));
  SET_HW_REGISTER (DDR_DMA_DST_ADDR_HI, (uint32_t) (ddr_addr >> 32));
  SET_HW_REGISTER (DDR_DMA_CTRL, (byte_cnt | 0x80000000));  /* transfer from host memory into DDR */
  while (HW_REGISTER (DDR_DMA_STATUS) != 0);
#endif
  NLM_SPIN_UNLOCK (&phy_device->ddr_dma_area_lock);
}

void
nlm_device_copy_from_ddr (nlm_phy_device_t *phy_device, nlm_phys_addr ddr_addr, uint32_t byte_cnt)
{
  nlm_phys_addr host_phys_addr = CONVERT_TO_PHYSICAL (phy_device->ddr_dma_area);

  printf("[%s] ddr_addr:0x%x, val:0x%x\n", __FUNCTION__, ddr_addr, (1ull << 61));
  
  /* 61-st bit of addr should be set to indicate DDR */
//  pretty_assert (ddr_addr & (1ull << 61));

  /* DMA engine support only 2**24 byte transfers */
  pretty_assert ((byte_cnt >> 24) == 0 && byte_cnt != 0);
  
  NLM_SPIN_LOCK (&phy_device->ddr_dma_area_lock);
  SET_HW_REGISTER (DDR_DMA_SRC_ADDR_LO, (uint32_t) (ddr_addr));
  SET_HW_REGISTER (DDR_DMA_SRC_ADDR_HI, (uint32_t) (ddr_addr >> 32));
  SET_HW_REGISTER (DDR_DMA_DST_ADDR_LO, (uint32_t) (host_phys_addr));
  SET_HW_REGISTER (DDR_DMA_DST_ADDR_HI, (uint32_t) (host_phys_addr >> 32));
  SET_HW_REGISTER (DDR_DMA_CTRL, (byte_cnt | 0x40000000));  /* transfer from DDR into host memory */
  while (HW_REGISTER (DDR_DMA_STATUS) != 0);
  NLM_SPIN_UNLOCK (&phy_device->ddr_dma_area_lock);
}

static void
debug_ddr (nlm_phy_device_t *phy_device, uint64_t ddr_addr)
{
  int i;
  uint64_t byte_cnt = MIN (NLM_DDR_DMA_AREA_SIZE, 64);
 
  nlm_device_copy_from_ddr (phy_device, ddr_addr, byte_cnt);

  for (i = 0; i < byte_cnt; i += sizeof (uint32_t))
    printf("addr=0x%x value = 0x%x\n", ddr_addr + i, ((uint32_t *) phy_device->ddr_dma_area)[i / sizeof (uint32_t)]);
   // DDPRINT ("addr=0x%"PRIx64" value = 0x%x\n", ddr_addr + i, ((uint32_t *) phy_device->ddr_dma_area)[i / sizeof (uint32_t)]);
}

#define SHELL_BURST_SIZE 0x1000000 /* 16 Mbyte per shell iteration */

#define DDR_MAX_MEM_SIZE (1 * 1024 * 1024 * 1024) /* 1 Gbyte */

nlm_status
nlm_device_init_ddr_memory (nlm_phy_device_t *phy_device, uint64_t *size)
{
  uint64_t ddr_addr;
  
  printf("[%s] ingress\n", __FUNCTION__);

  pretty_assert (HW_REGISTER (SYS_CONTROL) == 0); /* DMA must be disabled */

  if (NLM_USE_DDR2)
    TRY (nlm_device_ddr2_train (phy_device))
  else
    {
      TRY (nlm_device_ddr3_static_train (phy_device))
      // TRY (nlm_device_ddr3_train (phy_device))
    }

  return NLM_OK; /* DEBUG */

     // TRY (nlm_device_ddr3_train (phy_device))

  SET_HW_REGISTER (SHELL_CONTROL, 2); /* enable DDR shell */

  /* init DDR using 'shell' @addr = addr */
  for (ddr_addr = 0; ddr_addr < DDR_MAX_MEM_SIZE; ddr_addr += SHELL_BURST_SIZE)
    {
      DPRINT ("Starting DDR init @%"PRIx64"\n", ddr_addr);
      printf("Starting DDR init 0x%x\n", ddr_addr);
      SET_HW_REGISTER (SHELL_ADDR_LO, (uint32_t) (ddr_addr));
      SET_HW_REGISTER (SHELL_ADDR_HI, (uint32_t) (ddr_addr >> 32));
      SET_HW_REGISTER (SHELL_ADDR_SIZE, SHELL_BURST_SIZE - 1);
      SET_HW_REGISTER (SHELL_CMD, 1 << 16); /* write command */
      while (HW_REGISTER (SHELL_CMD) != 0); /* poll for completion */
    }

  SET_HW_REGISTER (SHELL_CONTROL, 0); /* disable shell */

  for (ddr_addr = 0; ddr_addr < DDR_MAX_MEM_SIZE; ddr_addr += SHELL_BURST_SIZE)
    debug_ddr (phy_device, ddr_addr);

  *size = 0;

  return NLM_OK;
}

